{-
   Opsgenie REST API

   Opsgenie OpenAPI Specification

   OpenAPI spec version: 2.0
   Opsgenie REST API API version: 2.0.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : OpsgenieREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpsgenieREST.Model where

import OpsgenieREST.Core
import OpsgenieREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Data, Typeable)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Text (Text)
import Prelude (($), (.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Models


-- ** AlertActionPayload
-- | AlertActionPayload
data AlertActionPayload = AlertActionPayload
  { alertActionPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , alertActionPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , alertActionPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertActionPayload
instance A.FromJSON AlertActionPayload where
  parseJSON = A.withObject "AlertActionPayload" $ \o ->
    AlertActionPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON AlertActionPayload
instance A.ToJSON AlertActionPayload where
  toJSON AlertActionPayload {..} =
   _omitNulls
      [ "user" .= alertActionPayloadUser
      , "note" .= alertActionPayloadNote
      , "source" .= alertActionPayloadSource
      ]


-- | Construct a value of type 'AlertActionPayload' (by applying it's required fields, if any)
mkAlertActionPayload
  :: AlertActionPayload
mkAlertActionPayload =
  AlertActionPayload
  { alertActionPayloadUser = Nothing
  , alertActionPayloadNote = Nothing
  , alertActionPayloadSource = Nothing
  }

-- ** AlertAttachment
-- | AlertAttachment
data AlertAttachment = AlertAttachment
  { alertAttachmentName :: !(Maybe Text) -- ^ "name"
  , alertAttachmentUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertAttachment
instance A.FromJSON AlertAttachment where
  parseJSON = A.withObject "AlertAttachment" $ \o ->
    AlertAttachment
      <$> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON AlertAttachment
instance A.ToJSON AlertAttachment where
  toJSON AlertAttachment {..} =
   _omitNulls
      [ "name" .= alertAttachmentName
      , "url" .= alertAttachmentUrl
      ]


-- | Construct a value of type 'AlertAttachment' (by applying it's required fields, if any)
mkAlertAttachment
  :: AlertAttachment
mkAlertAttachment =
  AlertAttachment
  { alertAttachmentName = Nothing
  , alertAttachmentUrl = Nothing
  }

-- ** AlertAttachmentMeta
-- | AlertAttachmentMeta
data AlertAttachmentMeta = AlertAttachmentMeta
  { alertAttachmentMetaName :: !(Maybe Text) -- ^ "name"
  , alertAttachmentMetaId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertAttachmentMeta
instance A.FromJSON AlertAttachmentMeta where
  parseJSON = A.withObject "AlertAttachmentMeta" $ \o ->
    AlertAttachmentMeta
      <$> (o .:? "name")
      <*> (o .:? "id")

-- | ToJSON AlertAttachmentMeta
instance A.ToJSON AlertAttachmentMeta where
  toJSON AlertAttachmentMeta {..} =
   _omitNulls
      [ "name" .= alertAttachmentMetaName
      , "id" .= alertAttachmentMetaId
      ]


-- | Construct a value of type 'AlertAttachmentMeta' (by applying it's required fields, if any)
mkAlertAttachmentMeta
  :: AlertAttachmentMeta
mkAlertAttachmentMeta =
  AlertAttachmentMeta
  { alertAttachmentMetaName = Nothing
  , alertAttachmentMetaId = Nothing
  }

-- ** AlertIntegration
-- | AlertIntegration
data AlertIntegration = AlertIntegration
  { alertIntegrationId :: !(Maybe Text) -- ^ "id"
  , alertIntegrationName :: !(Maybe Text) -- ^ "name"
  , alertIntegrationType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertIntegration
instance A.FromJSON AlertIntegration where
  parseJSON = A.withObject "AlertIntegration" $ \o ->
    AlertIntegration
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON AlertIntegration
instance A.ToJSON AlertIntegration where
  toJSON AlertIntegration {..} =
   _omitNulls
      [ "id" .= alertIntegrationId
      , "name" .= alertIntegrationName
      , "type" .= alertIntegrationType
      ]


-- | Construct a value of type 'AlertIntegration' (by applying it's required fields, if any)
mkAlertIntegration
  :: AlertIntegration
mkAlertIntegration =
  AlertIntegration
  { alertIntegrationId = Nothing
  , alertIntegrationName = Nothing
  , alertIntegrationType = Nothing
  }

-- ** AlertLog
-- | AlertLog
data AlertLog = AlertLog
  { alertLogLog :: !(Maybe Text) -- ^ "log"
  , alertLogType :: !(Maybe Text) -- ^ "type"
  , alertLogOwner :: !(Maybe Text) -- ^ "owner"
  , alertLogCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , alertLogOffset :: !(Maybe Text) -- ^ "offset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertLog
instance A.FromJSON AlertLog where
  parseJSON = A.withObject "AlertLog" $ \o ->
    AlertLog
      <$> (o .:? "log")
      <*> (o .:? "type")
      <*> (o .:? "owner")
      <*> (o .:? "createdAt")
      <*> (o .:? "offset")

-- | ToJSON AlertLog
instance A.ToJSON AlertLog where
  toJSON AlertLog {..} =
   _omitNulls
      [ "log" .= alertLogLog
      , "type" .= alertLogType
      , "owner" .= alertLogOwner
      , "createdAt" .= alertLogCreatedAt
      , "offset" .= alertLogOffset
      ]


-- | Construct a value of type 'AlertLog' (by applying it's required fields, if any)
mkAlertLog
  :: AlertLog
mkAlertLog =
  AlertLog
  { alertLogLog = Nothing
  , alertLogType = Nothing
  , alertLogOwner = Nothing
  , alertLogCreatedAt = Nothing
  , alertLogOffset = Nothing
  }

-- ** AlertNote
-- | AlertNote
data AlertNote = AlertNote
  { alertNoteNote :: !(Maybe Text) -- ^ "note"
  , alertNoteOwner :: !(Maybe Text) -- ^ "owner"
  , alertNoteCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , alertNoteOffset :: !(Maybe Text) -- ^ "offset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertNote
instance A.FromJSON AlertNote where
  parseJSON = A.withObject "AlertNote" $ \o ->
    AlertNote
      <$> (o .:? "note")
      <*> (o .:? "owner")
      <*> (o .:? "createdAt")
      <*> (o .:? "offset")

-- | ToJSON AlertNote
instance A.ToJSON AlertNote where
  toJSON AlertNote {..} =
   _omitNulls
      [ "note" .= alertNoteNote
      , "owner" .= alertNoteOwner
      , "createdAt" .= alertNoteCreatedAt
      , "offset" .= alertNoteOffset
      ]


-- | Construct a value of type 'AlertNote' (by applying it's required fields, if any)
mkAlertNote
  :: AlertNote
mkAlertNote =
  AlertNote
  { alertNoteNote = Nothing
  , alertNoteOwner = Nothing
  , alertNoteCreatedAt = Nothing
  , alertNoteOffset = Nothing
  }

-- ** AlertPaging
-- | AlertPaging
data AlertPaging = AlertPaging
  { alertPagingFirst :: !(Maybe Text) -- ^ "first"
  , alertPagingNext :: !(Maybe Text) -- ^ "next"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertPaging
instance A.FromJSON AlertPaging where
  parseJSON = A.withObject "AlertPaging" $ \o ->
    AlertPaging
      <$> (o .:? "first")
      <*> (o .:? "next")

-- | ToJSON AlertPaging
instance A.ToJSON AlertPaging where
  toJSON AlertPaging {..} =
   _omitNulls
      [ "first" .= alertPagingFirst
      , "next" .= alertPagingNext
      ]


-- | Construct a value of type 'AlertPaging' (by applying it's required fields, if any)
mkAlertPaging
  :: AlertPaging
mkAlertPaging =
  AlertPaging
  { alertPagingFirst = Nothing
  , alertPagingNext = Nothing
  }

-- ** AlertRecipient
-- | AlertRecipient
data AlertRecipient = AlertRecipient
  { alertRecipientUser :: !(Maybe AlertUserMeta) -- ^ "user"
  , alertRecipientState :: !(Maybe Text) -- ^ "state"
  , alertRecipientMethod :: !(Maybe Text) -- ^ "method"
  , alertRecipientCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , alertRecipientUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertRecipient
instance A.FromJSON AlertRecipient where
  parseJSON = A.withObject "AlertRecipient" $ \o ->
    AlertRecipient
      <$> (o .:? "user")
      <*> (o .:? "state")
      <*> (o .:? "method")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")

-- | ToJSON AlertRecipient
instance A.ToJSON AlertRecipient where
  toJSON AlertRecipient {..} =
   _omitNulls
      [ "user" .= alertRecipientUser
      , "state" .= alertRecipientState
      , "method" .= alertRecipientMethod
      , "createdAt" .= alertRecipientCreatedAt
      , "updatedAt" .= alertRecipientUpdatedAt
      ]


-- | Construct a value of type 'AlertRecipient' (by applying it's required fields, if any)
mkAlertRecipient
  :: AlertRecipient
mkAlertRecipient =
  AlertRecipient
  { alertRecipientUser = Nothing
  , alertRecipientState = Nothing
  , alertRecipientMethod = Nothing
  , alertRecipientCreatedAt = Nothing
  , alertRecipientUpdatedAt = Nothing
  }

-- ** AlertReport
-- | AlertReport
data AlertReport = AlertReport
  { alertReportAckTime :: !(Maybe Integer) -- ^ "ackTime"
  , alertReportCloseTime :: !(Maybe Integer) -- ^ "closeTime"
  , alertReportAcknowledgedBy :: !(Maybe Text) -- ^ "acknowledgedBy"
  , alertReportClosedBy :: !(Maybe Text) -- ^ "closedBy"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertReport
instance A.FromJSON AlertReport where
  parseJSON = A.withObject "AlertReport" $ \o ->
    AlertReport
      <$> (o .:? "ackTime")
      <*> (o .:? "closeTime")
      <*> (o .:? "acknowledgedBy")
      <*> (o .:? "closedBy")

-- | ToJSON AlertReport
instance A.ToJSON AlertReport where
  toJSON AlertReport {..} =
   _omitNulls
      [ "ackTime" .= alertReportAckTime
      , "closeTime" .= alertReportCloseTime
      , "acknowledgedBy" .= alertReportAcknowledgedBy
      , "closedBy" .= alertReportClosedBy
      ]


-- | Construct a value of type 'AlertReport' (by applying it's required fields, if any)
mkAlertReport
  :: AlertReport
mkAlertReport =
  AlertReport
  { alertReportAckTime = Nothing
  , alertReportCloseTime = Nothing
  , alertReportAcknowledgedBy = Nothing
  , alertReportClosedBy = Nothing
  }

-- ** AlertRequestStatus
-- | AlertRequestStatus
data AlertRequestStatus = AlertRequestStatus
  { alertRequestStatusAction :: !(Maybe Text) -- ^ "action"
  , alertRequestStatusProcessedAt :: !(Maybe DateTime) -- ^ "processedAt"
  , alertRequestStatusIntegrationId :: !(Maybe Text) -- ^ "integrationId"
  , alertRequestStatusIsSuccess :: !(Maybe Bool) -- ^ "isSuccess"
  , alertRequestStatusStatus :: !(Maybe Text) -- ^ "status"
  , alertRequestStatusAlertId :: !(Maybe Text) -- ^ "alertId"
  , alertRequestStatusAlias :: !(Maybe Text) -- ^ "alias"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertRequestStatus
instance A.FromJSON AlertRequestStatus where
  parseJSON = A.withObject "AlertRequestStatus" $ \o ->
    AlertRequestStatus
      <$> (o .:? "action")
      <*> (o .:? "processedAt")
      <*> (o .:? "integrationId")
      <*> (o .:? "isSuccess")
      <*> (o .:? "status")
      <*> (o .:? "alertId")
      <*> (o .:? "alias")

-- | ToJSON AlertRequestStatus
instance A.ToJSON AlertRequestStatus where
  toJSON AlertRequestStatus {..} =
   _omitNulls
      [ "action" .= alertRequestStatusAction
      , "processedAt" .= alertRequestStatusProcessedAt
      , "integrationId" .= alertRequestStatusIntegrationId
      , "isSuccess" .= alertRequestStatusIsSuccess
      , "status" .= alertRequestStatusStatus
      , "alertId" .= alertRequestStatusAlertId
      , "alias" .= alertRequestStatusAlias
      ]


-- | Construct a value of type 'AlertRequestStatus' (by applying it's required fields, if any)
mkAlertRequestStatus
  :: AlertRequestStatus
mkAlertRequestStatus =
  AlertRequestStatus
  { alertRequestStatusAction = Nothing
  , alertRequestStatusProcessedAt = Nothing
  , alertRequestStatusIntegrationId = Nothing
  , alertRequestStatusIsSuccess = Nothing
  , alertRequestStatusStatus = Nothing
  , alertRequestStatusAlertId = Nothing
  , alertRequestStatusAlias = Nothing
  }

-- ** AlertTeamMeta
-- | AlertTeamMeta
data AlertTeamMeta = AlertTeamMeta
  { alertTeamMetaId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertTeamMeta
instance A.FromJSON AlertTeamMeta where
  parseJSON = A.withObject "AlertTeamMeta" $ \o ->
    AlertTeamMeta
      <$> (o .:  "id")

-- | ToJSON AlertTeamMeta
instance A.ToJSON AlertTeamMeta where
  toJSON AlertTeamMeta {..} =
   _omitNulls
      [ "id" .= alertTeamMetaId
      ]


-- | Construct a value of type 'AlertTeamMeta' (by applying it's required fields, if any)
mkAlertTeamMeta
  :: Text -- ^ 'alertTeamMetaId' 
  -> AlertTeamMeta
mkAlertTeamMeta alertTeamMetaId =
  AlertTeamMeta
  { alertTeamMetaId
  }

-- ** AlertUserMeta
-- | AlertUserMeta
data AlertUserMeta = AlertUserMeta
  { alertUserMetaId :: !(Maybe Text) -- ^ "id"
  , alertUserMetaUsername :: !(Maybe Text) -- ^ "username"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertUserMeta
instance A.FromJSON AlertUserMeta where
  parseJSON = A.withObject "AlertUserMeta" $ \o ->
    AlertUserMeta
      <$> (o .:? "id")
      <*> (o .:? "username")

-- | ToJSON AlertUserMeta
instance A.ToJSON AlertUserMeta where
  toJSON AlertUserMeta {..} =
   _omitNulls
      [ "id" .= alertUserMetaId
      , "username" .= alertUserMetaUsername
      ]


-- | Construct a value of type 'AlertUserMeta' (by applying it's required fields, if any)
mkAlertUserMeta
  :: AlertUserMeta
mkAlertUserMeta =
  AlertUserMeta
  { alertUserMetaId = Nothing
  , alertUserMetaUsername = Nothing
  }

-- ** BaseAlert
-- | BaseAlert
data BaseAlert = BaseAlert
  { baseAlertId :: !(Text) -- ^ /Required/ "id"
  , baseAlertTinyId :: !(Maybe Text) -- ^ "tinyId"
  , baseAlertAlias :: !(Maybe Text) -- ^ "alias"
  , baseAlertMessage :: !(Maybe Text) -- ^ "message"
  , baseAlertStatus :: !(Maybe Text) -- ^ "status"
  , baseAlertAcknowledged :: !(Maybe Bool) -- ^ "acknowledged"
  , baseAlertIsSeen :: !(Maybe Bool) -- ^ "isSeen"
  , baseAlertTags :: !(Maybe [Text]) -- ^ "tags"
  , baseAlertSnoozed :: !(Maybe Bool) -- ^ "snoozed"
  , baseAlertSnoozedUntil :: !(Maybe DateTime) -- ^ "snoozedUntil"
  , baseAlertCount :: !(Maybe Int) -- ^ "count"
  , baseAlertLastOccurredAt :: !(Maybe DateTime) -- ^ "lastOccurredAt"
  , baseAlertCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , baseAlertUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt"
  , baseAlertSource :: !(Maybe Text) -- ^ "source"
  , baseAlertOwner :: !(Maybe Text) -- ^ "owner"
  , baseAlertPriority :: !(Maybe Text) -- ^ "priority"
  , baseAlertResponders :: !(Maybe [Responder]) -- ^ "responders"
  , baseAlertIntegration :: !(Maybe AlertIntegration) -- ^ "integration"
  , baseAlertReport :: !(Maybe AlertReport) -- ^ "report"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseAlert
instance A.FromJSON BaseAlert where
  parseJSON = A.withObject "BaseAlert" $ \o ->
    BaseAlert
      <$> (o .:  "id")
      <*> (o .:? "tinyId")
      <*> (o .:? "alias")
      <*> (o .:? "message")
      <*> (o .:? "status")
      <*> (o .:? "acknowledged")
      <*> (o .:? "isSeen")
      <*> (o .:? "tags")
      <*> (o .:? "snoozed")
      <*> (o .:? "snoozedUntil")
      <*> (o .:? "count")
      <*> (o .:? "lastOccurredAt")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "source")
      <*> (o .:? "owner")
      <*> (o .:? "priority")
      <*> (o .:? "responders")
      <*> (o .:? "integration")
      <*> (o .:? "report")

-- | ToJSON BaseAlert
instance A.ToJSON BaseAlert where
  toJSON BaseAlert {..} =
   _omitNulls
      [ "id" .= baseAlertId
      , "tinyId" .= baseAlertTinyId
      , "alias" .= baseAlertAlias
      , "message" .= baseAlertMessage
      , "status" .= baseAlertStatus
      , "acknowledged" .= baseAlertAcknowledged
      , "isSeen" .= baseAlertIsSeen
      , "tags" .= baseAlertTags
      , "snoozed" .= baseAlertSnoozed
      , "snoozedUntil" .= baseAlertSnoozedUntil
      , "count" .= baseAlertCount
      , "lastOccurredAt" .= baseAlertLastOccurredAt
      , "createdAt" .= baseAlertCreatedAt
      , "updatedAt" .= baseAlertUpdatedAt
      , "source" .= baseAlertSource
      , "owner" .= baseAlertOwner
      , "priority" .= baseAlertPriority
      , "responders" .= baseAlertResponders
      , "integration" .= baseAlertIntegration
      , "report" .= baseAlertReport
      ]


-- | Construct a value of type 'BaseAlert' (by applying it's required fields, if any)
mkBaseAlert
  :: Text -- ^ 'baseAlertId' 
  -> BaseAlert
mkBaseAlert baseAlertId =
  BaseAlert
  { baseAlertId
  , baseAlertTinyId = Nothing
  , baseAlertAlias = Nothing
  , baseAlertMessage = Nothing
  , baseAlertStatus = Nothing
  , baseAlertAcknowledged = Nothing
  , baseAlertIsSeen = Nothing
  , baseAlertTags = Nothing
  , baseAlertSnoozed = Nothing
  , baseAlertSnoozedUntil = Nothing
  , baseAlertCount = Nothing
  , baseAlertLastOccurredAt = Nothing
  , baseAlertCreatedAt = Nothing
  , baseAlertUpdatedAt = Nothing
  , baseAlertSource = Nothing
  , baseAlertOwner = Nothing
  , baseAlertPriority = Nothing
  , baseAlertResponders = Nothing
  , baseAlertIntegration = Nothing
  , baseAlertReport = Nothing
  }

-- ** BaseResponse
-- | BaseResponse
data BaseResponse = BaseResponse
  { baseResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , baseResponseTook :: !(Float) -- ^ /Required/ "took"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseResponse
instance A.FromJSON BaseResponse where
  parseJSON = A.withObject "BaseResponse" $ \o ->
    BaseResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")

-- | ToJSON BaseResponse
instance A.ToJSON BaseResponse where
  toJSON BaseResponse {..} =
   _omitNulls
      [ "requestId" .= baseResponseRequestId
      , "took" .= baseResponseTook
      ]


-- | Construct a value of type 'BaseResponse' (by applying it's required fields, if any)
mkBaseResponse
  :: Text -- ^ 'baseResponseRequestId' 
  -> Float -- ^ 'baseResponseTook' 
  -> BaseResponse
mkBaseResponse baseResponseRequestId baseResponseTook =
  BaseResponse
  { baseResponseRequestId
  , baseResponseTook
  }

-- ** Condition
-- | Condition
data Condition = Condition
  { conditionField :: !(E'Field) -- ^ /Required/ "field" - Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients or teams
  , conditionKey :: !(Maybe Text) -- ^ "key" - If field is set as extra-properties, key could be used for key-value pair
  , conditionNot :: !(Maybe Bool) -- ^ "not" - Indicates behaviour of the given operation. Default value is false
  , conditionOperation :: !(E'Operation) -- ^ /Required/ "operation" - It is the operation that will be executed for the given field and key.
  , conditionExpectedValue :: !(Maybe Text) -- ^ "expectedValue" - User defined value that will be compared with alert field according to the operation. Default value is empty string
  , conditionOrder :: !(Maybe Integer) -- ^ "order" - Order of the condition in conditions list
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Condition
instance A.FromJSON Condition where
  parseJSON = A.withObject "Condition" $ \o ->
    Condition
      <$> (o .:  "field")
      <*> (o .:? "key")
      <*> (o .:? "not")
      <*> (o .:  "operation")
      <*> (o .:? "expectedValue")
      <*> (o .:? "order")

-- | ToJSON Condition
instance A.ToJSON Condition where
  toJSON Condition {..} =
   _omitNulls
      [ "field" .= conditionField
      , "key" .= conditionKey
      , "not" .= conditionNot
      , "operation" .= conditionOperation
      , "expectedValue" .= conditionExpectedValue
      , "order" .= conditionOrder
      ]


-- | Construct a value of type 'Condition' (by applying it's required fields, if any)
mkCondition
  :: E'Field -- ^ 'conditionField': Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients or teams
  -> E'Operation -- ^ 'conditionOperation': It is the operation that will be executed for the given field and key.
  -> Condition
mkCondition conditionField conditionOperation =
  Condition
  { conditionField
  , conditionKey = Nothing
  , conditionNot = Nothing
  , conditionOperation
  , conditionExpectedValue = Nothing
  , conditionOrder = Nothing
  }

-- ** CreateSavedSearchPayload
-- | CreateSavedSearchPayload
data CreateSavedSearchPayload = CreateSavedSearchPayload
  { createSavedSearchPayloadName :: !(Text) -- ^ /Required/ "name"
  , createSavedSearchPayloadDescription :: !(Maybe Text) -- ^ "description"
  , createSavedSearchPayloadQuery :: !(Text) -- ^ /Required/ "query"
  , createSavedSearchPayloadOwner :: !(UserRecipient) -- ^ /Required/ "owner"
  , createSavedSearchPayloadTeams :: !(Maybe [TeamRecipient]) -- ^ "teams" - Teams that the alert will be routed to send notifications
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSavedSearchPayload
instance A.FromJSON CreateSavedSearchPayload where
  parseJSON = A.withObject "CreateSavedSearchPayload" $ \o ->
    CreateSavedSearchPayload
      <$> (o .:  "name")
      <*> (o .:? "description")
      <*> (o .:  "query")
      <*> (o .:  "owner")
      <*> (o .:? "teams")

-- | ToJSON CreateSavedSearchPayload
instance A.ToJSON CreateSavedSearchPayload where
  toJSON CreateSavedSearchPayload {..} =
   _omitNulls
      [ "name" .= createSavedSearchPayloadName
      , "description" .= createSavedSearchPayloadDescription
      , "query" .= createSavedSearchPayloadQuery
      , "owner" .= createSavedSearchPayloadOwner
      , "teams" .= createSavedSearchPayloadTeams
      ]


-- | Construct a value of type 'CreateSavedSearchPayload' (by applying it's required fields, if any)
mkCreateSavedSearchPayload
  :: Text -- ^ 'createSavedSearchPayloadName' 
  -> Text -- ^ 'createSavedSearchPayloadQuery' 
  -> UserRecipient -- ^ 'createSavedSearchPayloadOwner' 
  -> CreateSavedSearchPayload
mkCreateSavedSearchPayload createSavedSearchPayloadName createSavedSearchPayloadQuery createSavedSearchPayloadOwner =
  CreateSavedSearchPayload
  { createSavedSearchPayloadName
  , createSavedSearchPayloadDescription = Nothing
  , createSavedSearchPayloadQuery
  , createSavedSearchPayloadOwner
  , createSavedSearchPayloadTeams = Nothing
  }

-- ** Duration
-- | Duration
data Duration = Duration
  { durationTimeAmount :: !(Integer) -- ^ /Required/ "timeAmount"
  , durationTimeUnit :: !(Maybe E'TimeUnit) -- ^ "timeUnit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Duration
instance A.FromJSON Duration where
  parseJSON = A.withObject "Duration" $ \o ->
    Duration
      <$> (o .:  "timeAmount")
      <*> (o .:? "timeUnit")

-- | ToJSON Duration
instance A.ToJSON Duration where
  toJSON Duration {..} =
   _omitNulls
      [ "timeAmount" .= durationTimeAmount
      , "timeUnit" .= durationTimeUnit
      ]


-- | Construct a value of type 'Duration' (by applying it's required fields, if any)
mkDuration
  :: Integer -- ^ 'durationTimeAmount' 
  -> Duration
mkDuration durationTimeAmount =
  Duration
  { durationTimeAmount
  , durationTimeUnit = Nothing
  }

-- ** Filter
-- | Filter
-- Defines the conditions that will be checked before applying rules and type of the operations that will be applied on conditions
data Filter = Filter
  { filterType :: !(E'Type3) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Filter
instance A.FromJSON Filter where
  parseJSON = A.withObject "Filter" $ \o ->
    Filter
      <$> (o .:  "type")

-- | ToJSON Filter
instance A.ToJSON Filter where
  toJSON Filter {..} =
   _omitNulls
      [ "type" .= filterType
      ]


-- | Construct a value of type 'Filter' (by applying it's required fields, if any)
mkFilter
  :: E'Type3 -- ^ 'filterType' 
  -> Filter
mkFilter filterType =
  Filter
  { filterType
  }

-- ** GetCountAlertsResponseData
-- | GetCountAlertsResponseData
data GetCountAlertsResponseData = GetCountAlertsResponseData
  { getCountAlertsResponseDataCount :: !(Maybe Int) -- ^ "count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCountAlertsResponseData
instance A.FromJSON GetCountAlertsResponseData where
  parseJSON = A.withObject "GetCountAlertsResponseData" $ \o ->
    GetCountAlertsResponseData
      <$> (o .:? "count")

-- | ToJSON GetCountAlertsResponseData
instance A.ToJSON GetCountAlertsResponseData where
  toJSON GetCountAlertsResponseData {..} =
   _omitNulls
      [ "count" .= getCountAlertsResponseDataCount
      ]


-- | Construct a value of type 'GetCountAlertsResponseData' (by applying it's required fields, if any)
mkGetCountAlertsResponseData
  :: GetCountAlertsResponseData
mkGetCountAlertsResponseData =
  GetCountAlertsResponseData
  { getCountAlertsResponseDataCount = Nothing
  }

-- ** PageDetails
-- | PageDetails
data PageDetails = PageDetails
  { pageDetailsPrev :: !(Maybe Text) -- ^ "prev"
  , pageDetailsNext :: !(Maybe Text) -- ^ "next"
  , pageDetailsFirst :: !(Maybe Text) -- ^ "first"
  , pageDetailsLast :: !(Maybe Text) -- ^ "last"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PageDetails
instance A.FromJSON PageDetails where
  parseJSON = A.withObject "PageDetails" $ \o ->
    PageDetails
      <$> (o .:? "prev")
      <*> (o .:? "next")
      <*> (o .:? "first")
      <*> (o .:? "last")

-- | ToJSON PageDetails
instance A.ToJSON PageDetails where
  toJSON PageDetails {..} =
   _omitNulls
      [ "prev" .= pageDetailsPrev
      , "next" .= pageDetailsNext
      , "first" .= pageDetailsFirst
      , "last" .= pageDetailsLast
      ]


-- | Construct a value of type 'PageDetails' (by applying it's required fields, if any)
mkPageDetails
  :: PageDetails
mkPageDetails =
  PageDetails
  { pageDetailsPrev = Nothing
  , pageDetailsNext = Nothing
  , pageDetailsFirst = Nothing
  , pageDetailsLast = Nothing
  }

-- ** Recipient
-- | Recipient
data Recipient = Recipient
  { recipientType :: !(E'Type) -- ^ /Required/ "type"
  , recipientId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Recipient
instance A.FromJSON Recipient where
  parseJSON = A.withObject "Recipient" $ \o ->
    Recipient
      <$> (o .:  "type")
      <*> (o .:? "id")

-- | ToJSON Recipient
instance A.ToJSON Recipient where
  toJSON Recipient {..} =
   _omitNulls
      [ "type" .= recipientType
      , "id" .= recipientId
      ]


-- | Construct a value of type 'Recipient' (by applying it's required fields, if any)
mkRecipient
  :: E'Type -- ^ 'recipientType' 
  -> Recipient
mkRecipient recipientType =
  Recipient
  { recipientType
  , recipientId = Nothing
  }

-- ** Responder
-- | Responder
data Responder = Responder
  { responderType :: !(E'Type4) -- ^ /Required/ "type"
  , responderId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Responder
instance A.FromJSON Responder where
  parseJSON = A.withObject "Responder" $ \o ->
    Responder
      <$> (o .:  "type")
      <*> (o .:  "id")

-- | ToJSON Responder
instance A.ToJSON Responder where
  toJSON Responder {..} =
   _omitNulls
      [ "type" .= responderType
      , "id" .= responderId
      ]


-- | Construct a value of type 'Responder' (by applying it's required fields, if any)
mkResponder
  :: E'Type4 -- ^ 'responderType' 
  -> Text -- ^ 'responderId' 
  -> Responder
mkResponder responderType responderId =
  Responder
  { responderType
  , responderId
  }

-- ** SavedSearch
-- | SavedSearch
data SavedSearch = SavedSearch
  { savedSearchId :: !(Maybe Text) -- ^ "id"
  , savedSearchName :: !(Maybe Text) -- ^ "name"
  , savedSearchCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , savedSearchUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt"
  , savedSearchOwner :: !(Maybe SavedSearchEntity) -- ^ "owner"
  , savedSearchTeams :: !(Maybe [SavedSearchEntity]) -- ^ "teams"
  , savedSearchDescription :: !(Maybe Text) -- ^ "description"
  , savedSearchQuery :: !(Maybe Text) -- ^ "query"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SavedSearch
instance A.FromJSON SavedSearch where
  parseJSON = A.withObject "SavedSearch" $ \o ->
    SavedSearch
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "owner")
      <*> (o .:? "teams")
      <*> (o .:? "description")
      <*> (o .:? "query")

-- | ToJSON SavedSearch
instance A.ToJSON SavedSearch where
  toJSON SavedSearch {..} =
   _omitNulls
      [ "id" .= savedSearchId
      , "name" .= savedSearchName
      , "createdAt" .= savedSearchCreatedAt
      , "updatedAt" .= savedSearchUpdatedAt
      , "owner" .= savedSearchOwner
      , "teams" .= savedSearchTeams
      , "description" .= savedSearchDescription
      , "query" .= savedSearchQuery
      ]


-- | Construct a value of type 'SavedSearch' (by applying it's required fields, if any)
mkSavedSearch
  :: SavedSearch
mkSavedSearch =
  SavedSearch
  { savedSearchId = Nothing
  , savedSearchName = Nothing
  , savedSearchCreatedAt = Nothing
  , savedSearchUpdatedAt = Nothing
  , savedSearchOwner = Nothing
  , savedSearchTeams = Nothing
  , savedSearchDescription = Nothing
  , savedSearchQuery = Nothing
  }

-- ** SavedSearchEntity
-- | SavedSearchEntity
data SavedSearchEntity = SavedSearchEntity
  { savedSearchEntityId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SavedSearchEntity
instance A.FromJSON SavedSearchEntity where
  parseJSON = A.withObject "SavedSearchEntity" $ \o ->
    SavedSearchEntity
      <$> (o .:? "id")

-- | ToJSON SavedSearchEntity
instance A.ToJSON SavedSearchEntity where
  toJSON SavedSearchEntity {..} =
   _omitNulls
      [ "id" .= savedSearchEntityId
      ]


-- | Construct a value of type 'SavedSearchEntity' (by applying it's required fields, if any)
mkSavedSearchEntity
  :: SavedSearchEntity
mkSavedSearchEntity =
  SavedSearchEntity
  { savedSearchEntityId = Nothing
  }

-- ** SavedSearchMeta
-- | SavedSearchMeta
data SavedSearchMeta = SavedSearchMeta
  { savedSearchMetaId :: !(Maybe Text) -- ^ "id"
  , savedSearchMetaName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SavedSearchMeta
instance A.FromJSON SavedSearchMeta where
  parseJSON = A.withObject "SavedSearchMeta" $ \o ->
    SavedSearchMeta
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON SavedSearchMeta
instance A.ToJSON SavedSearchMeta where
  toJSON SavedSearchMeta {..} =
   _omitNulls
      [ "id" .= savedSearchMetaId
      , "name" .= savedSearchMetaName
      ]


-- | Construct a value of type 'SavedSearchMeta' (by applying it's required fields, if any)
mkSavedSearchMeta
  :: SavedSearchMeta
mkSavedSearchMeta =
  SavedSearchMeta
  { savedSearchMetaId = Nothing
  , savedSearchMetaName = Nothing
  }

-- ** SuccessData
-- | SuccessData
data SuccessData = SuccessData
  { successDataId :: !(Maybe Text) -- ^ "id"
  , successDataName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuccessData
instance A.FromJSON SuccessData where
  parseJSON = A.withObject "SuccessData" $ \o ->
    SuccessData
      <$> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON SuccessData
instance A.ToJSON SuccessData where
  toJSON SuccessData {..} =
   _omitNulls
      [ "id" .= successDataId
      , "name" .= successDataName
      ]


-- | Construct a value of type 'SuccessData' (by applying it's required fields, if any)
mkSuccessData
  :: SuccessData
mkSuccessData =
  SuccessData
  { successDataId = Nothing
  , successDataName = Nothing
  }

-- ** TimeOfDayRestriction
-- | TimeOfDayRestriction
data TimeOfDayRestriction = TimeOfDayRestriction
  { timeOfDayRestrictionStartHour :: !(Maybe Int) -- ^ "startHour"
  , timeOfDayRestrictionStartMin :: !(Maybe Int) -- ^ "startMin"
  , timeOfDayRestrictionEndHour :: !(Maybe Int) -- ^ "endHour"
  , timeOfDayRestrictionEndMin :: !(Maybe Int) -- ^ "endMin"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimeOfDayRestriction
instance A.FromJSON TimeOfDayRestriction where
  parseJSON = A.withObject "TimeOfDayRestriction" $ \o ->
    TimeOfDayRestriction
      <$> (o .:? "startHour")
      <*> (o .:? "startMin")
      <*> (o .:? "endHour")
      <*> (o .:? "endMin")

-- | ToJSON TimeOfDayRestriction
instance A.ToJSON TimeOfDayRestriction where
  toJSON TimeOfDayRestriction {..} =
   _omitNulls
      [ "startHour" .= timeOfDayRestrictionStartHour
      , "startMin" .= timeOfDayRestrictionStartMin
      , "endHour" .= timeOfDayRestrictionEndHour
      , "endMin" .= timeOfDayRestrictionEndMin
      ]


-- | Construct a value of type 'TimeOfDayRestriction' (by applying it's required fields, if any)
mkTimeOfDayRestriction
  :: TimeOfDayRestriction
mkTimeOfDayRestriction =
  TimeOfDayRestriction
  { timeOfDayRestrictionStartHour = Nothing
  , timeOfDayRestrictionStartMin = Nothing
  , timeOfDayRestrictionEndHour = Nothing
  , timeOfDayRestrictionEndMin = Nothing
  }

-- ** TimeRestrictionInterval
-- | TimeRestrictionInterval
data TimeRestrictionInterval = TimeRestrictionInterval
  { timeRestrictionIntervalType :: !(E'Type2) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimeRestrictionInterval
instance A.FromJSON TimeRestrictionInterval where
  parseJSON = A.withObject "TimeRestrictionInterval" $ \o ->
    TimeRestrictionInterval
      <$> (o .:  "type")

-- | ToJSON TimeRestrictionInterval
instance A.ToJSON TimeRestrictionInterval where
  toJSON TimeRestrictionInterval {..} =
   _omitNulls
      [ "type" .= timeRestrictionIntervalType
      ]


-- | Construct a value of type 'TimeRestrictionInterval' (by applying it's required fields, if any)
mkTimeRestrictionInterval
  :: E'Type2 -- ^ 'timeRestrictionIntervalType' 
  -> TimeRestrictionInterval
mkTimeRestrictionInterval timeRestrictionIntervalType =
  TimeRestrictionInterval
  { timeRestrictionIntervalType
  }

-- ** UpdateAlertDescriptionPayload
-- | UpdateAlertDescriptionPayload
data UpdateAlertDescriptionPayload = UpdateAlertDescriptionPayload
  { updateAlertDescriptionPayloadDescription :: !(Text) -- ^ /Required/ "description" - Description of the alert
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAlertDescriptionPayload
instance A.FromJSON UpdateAlertDescriptionPayload where
  parseJSON = A.withObject "UpdateAlertDescriptionPayload" $ \o ->
    UpdateAlertDescriptionPayload
      <$> (o .:  "description")

-- | ToJSON UpdateAlertDescriptionPayload
instance A.ToJSON UpdateAlertDescriptionPayload where
  toJSON UpdateAlertDescriptionPayload {..} =
   _omitNulls
      [ "description" .= updateAlertDescriptionPayloadDescription
      ]


-- | Construct a value of type 'UpdateAlertDescriptionPayload' (by applying it's required fields, if any)
mkUpdateAlertDescriptionPayload
  :: Text -- ^ 'updateAlertDescriptionPayloadDescription': Description of the alert
  -> UpdateAlertDescriptionPayload
mkUpdateAlertDescriptionPayload updateAlertDescriptionPayloadDescription =
  UpdateAlertDescriptionPayload
  { updateAlertDescriptionPayloadDescription
  }

-- ** UpdateAlertMessagePayload
-- | UpdateAlertMessagePayload
data UpdateAlertMessagePayload = UpdateAlertMessagePayload
  { updateAlertMessagePayloadMessage :: !(Text) -- ^ /Required/ "message" - Message of the alert
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAlertMessagePayload
instance A.FromJSON UpdateAlertMessagePayload where
  parseJSON = A.withObject "UpdateAlertMessagePayload" $ \o ->
    UpdateAlertMessagePayload
      <$> (o .:  "message")

-- | ToJSON UpdateAlertMessagePayload
instance A.ToJSON UpdateAlertMessagePayload where
  toJSON UpdateAlertMessagePayload {..} =
   _omitNulls
      [ "message" .= updateAlertMessagePayloadMessage
      ]


-- | Construct a value of type 'UpdateAlertMessagePayload' (by applying it's required fields, if any)
mkUpdateAlertMessagePayload
  :: Text -- ^ 'updateAlertMessagePayloadMessage': Message of the alert
  -> UpdateAlertMessagePayload
mkUpdateAlertMessagePayload updateAlertMessagePayloadMessage =
  UpdateAlertMessagePayload
  { updateAlertMessagePayloadMessage
  }

-- ** UpdateAlertPriorityPayload
-- | UpdateAlertPriorityPayload
data UpdateAlertPriorityPayload = UpdateAlertPriorityPayload
  { updateAlertPriorityPayloadPriority :: !(E'Priority) -- ^ /Required/ "priority" - Priority level of the alert
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAlertPriorityPayload
instance A.FromJSON UpdateAlertPriorityPayload where
  parseJSON = A.withObject "UpdateAlertPriorityPayload" $ \o ->
    UpdateAlertPriorityPayload
      <$> (o .:  "priority")

-- | ToJSON UpdateAlertPriorityPayload
instance A.ToJSON UpdateAlertPriorityPayload where
  toJSON UpdateAlertPriorityPayload {..} =
   _omitNulls
      [ "priority" .= updateAlertPriorityPayloadPriority
      ]


-- | Construct a value of type 'UpdateAlertPriorityPayload' (by applying it's required fields, if any)
mkUpdateAlertPriorityPayload
  :: E'Priority -- ^ 'updateAlertPriorityPayloadPriority': Priority level of the alert
  -> UpdateAlertPriorityPayload
mkUpdateAlertPriorityPayload updateAlertPriorityPayloadPriority =
  UpdateAlertPriorityPayload
  { updateAlertPriorityPayloadPriority
  }

-- ** UpdateSavedSearchPayload
-- | UpdateSavedSearchPayload
data UpdateSavedSearchPayload = UpdateSavedSearchPayload
  { updateSavedSearchPayloadName :: !(Text) -- ^ /Required/ "name"
  , updateSavedSearchPayloadDescription :: !(Maybe Text) -- ^ "description"
  , updateSavedSearchPayloadQuery :: !(Text) -- ^ /Required/ "query"
  , updateSavedSearchPayloadOwner :: !(UserRecipient) -- ^ /Required/ "owner"
  , updateSavedSearchPayloadTeams :: !(Maybe [TeamRecipient]) -- ^ "teams" - Teams that the alert will be routed to send notifications
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSavedSearchPayload
instance A.FromJSON UpdateSavedSearchPayload where
  parseJSON = A.withObject "UpdateSavedSearchPayload" $ \o ->
    UpdateSavedSearchPayload
      <$> (o .:  "name")
      <*> (o .:? "description")
      <*> (o .:  "query")
      <*> (o .:  "owner")
      <*> (o .:? "teams")

-- | ToJSON UpdateSavedSearchPayload
instance A.ToJSON UpdateSavedSearchPayload where
  toJSON UpdateSavedSearchPayload {..} =
   _omitNulls
      [ "name" .= updateSavedSearchPayloadName
      , "description" .= updateSavedSearchPayloadDescription
      , "query" .= updateSavedSearchPayloadQuery
      , "owner" .= updateSavedSearchPayloadOwner
      , "teams" .= updateSavedSearchPayloadTeams
      ]


-- | Construct a value of type 'UpdateSavedSearchPayload' (by applying it's required fields, if any)
mkUpdateSavedSearchPayload
  :: Text -- ^ 'updateSavedSearchPayloadName' 
  -> Text -- ^ 'updateSavedSearchPayloadQuery' 
  -> UserRecipient -- ^ 'updateSavedSearchPayloadOwner' 
  -> UpdateSavedSearchPayload
mkUpdateSavedSearchPayload updateSavedSearchPayloadName updateSavedSearchPayloadQuery updateSavedSearchPayloadOwner =
  UpdateSavedSearchPayload
  { updateSavedSearchPayloadName
  , updateSavedSearchPayloadDescription = Nothing
  , updateSavedSearchPayloadQuery
  , updateSavedSearchPayloadOwner
  , updateSavedSearchPayloadTeams = Nothing
  }

-- ** WeekdayTimeRestriction
-- | WeekdayTimeRestriction
data WeekdayTimeRestriction = WeekdayTimeRestriction
  { weekdayTimeRestrictionStartDay :: !(Maybe E'StartDay) -- ^ "startDay"
  , weekdayTimeRestrictionStartHour :: !(Maybe Int) -- ^ "startHour"
  , weekdayTimeRestrictionStartMin :: !(Maybe Int) -- ^ "startMin"
  , weekdayTimeRestrictionEndDay :: !(Maybe E'StartDay) -- ^ "endDay"
  , weekdayTimeRestrictionEndHour :: !(Maybe Int) -- ^ "endHour"
  , weekdayTimeRestrictionEndMin :: !(Maybe Int) -- ^ "endMin"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WeekdayTimeRestriction
instance A.FromJSON WeekdayTimeRestriction where
  parseJSON = A.withObject "WeekdayTimeRestriction" $ \o ->
    WeekdayTimeRestriction
      <$> (o .:? "startDay")
      <*> (o .:? "startHour")
      <*> (o .:? "startMin")
      <*> (o .:? "endDay")
      <*> (o .:? "endHour")
      <*> (o .:? "endMin")

-- | ToJSON WeekdayTimeRestriction
instance A.ToJSON WeekdayTimeRestriction where
  toJSON WeekdayTimeRestriction {..} =
   _omitNulls
      [ "startDay" .= weekdayTimeRestrictionStartDay
      , "startHour" .= weekdayTimeRestrictionStartHour
      , "startMin" .= weekdayTimeRestrictionStartMin
      , "endDay" .= weekdayTimeRestrictionEndDay
      , "endHour" .= weekdayTimeRestrictionEndHour
      , "endMin" .= weekdayTimeRestrictionEndMin
      ]


-- | Construct a value of type 'WeekdayTimeRestriction' (by applying it's required fields, if any)
mkWeekdayTimeRestriction
  :: WeekdayTimeRestriction
mkWeekdayTimeRestriction =
  WeekdayTimeRestriction
  { weekdayTimeRestrictionStartDay = Nothing
  , weekdayTimeRestrictionStartHour = Nothing
  , weekdayTimeRestrictionStartMin = Nothing
  , weekdayTimeRestrictionEndDay = Nothing
  , weekdayTimeRestrictionEndHour = Nothing
  , weekdayTimeRestrictionEndMin = Nothing
  }

-- ** AcknowledgeAlertPayload
-- | AcknowledgeAlertPayload
data AcknowledgeAlertPayload = AcknowledgeAlertPayload
  { acknowledgeAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , acknowledgeAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , acknowledgeAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AcknowledgeAlertPayload
instance A.FromJSON AcknowledgeAlertPayload where
  parseJSON = A.withObject "AcknowledgeAlertPayload" $ \o ->
    AcknowledgeAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON AcknowledgeAlertPayload
instance A.ToJSON AcknowledgeAlertPayload where
  toJSON AcknowledgeAlertPayload {..} =
   _omitNulls
      [ "user" .= acknowledgeAlertPayloadUser
      , "note" .= acknowledgeAlertPayloadNote
      , "source" .= acknowledgeAlertPayloadSource
      ]


-- | Construct a value of type 'AcknowledgeAlertPayload' (by applying it's required fields, if any)
mkAcknowledgeAlertPayload
  :: AcknowledgeAlertPayload
mkAcknowledgeAlertPayload =
  AcknowledgeAlertPayload
  { acknowledgeAlertPayloadUser = Nothing
  , acknowledgeAlertPayloadNote = Nothing
  , acknowledgeAlertPayloadSource = Nothing
  }

-- ** AddDetailsToAlertPayload
-- | AddDetailsToAlertPayload
data AddDetailsToAlertPayload = AddDetailsToAlertPayload
  { addDetailsToAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , addDetailsToAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , addDetailsToAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , addDetailsToAlertPayloadDetails :: !((Map.Map String Text)) -- ^ /Required/ "details" - Key-value pairs to add as custom property into alert.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddDetailsToAlertPayload
instance A.FromJSON AddDetailsToAlertPayload where
  parseJSON = A.withObject "AddDetailsToAlertPayload" $ \o ->
    AddDetailsToAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "details")

-- | ToJSON AddDetailsToAlertPayload
instance A.ToJSON AddDetailsToAlertPayload where
  toJSON AddDetailsToAlertPayload {..} =
   _omitNulls
      [ "user" .= addDetailsToAlertPayloadUser
      , "note" .= addDetailsToAlertPayloadNote
      , "source" .= addDetailsToAlertPayloadSource
      , "details" .= addDetailsToAlertPayloadDetails
      ]


-- | Construct a value of type 'AddDetailsToAlertPayload' (by applying it's required fields, if any)
mkAddDetailsToAlertPayload
  :: (Map.Map String Text) -- ^ 'addDetailsToAlertPayloadDetails': Key-value pairs to add as custom property into alert.
  -> AddDetailsToAlertPayload
mkAddDetailsToAlertPayload addDetailsToAlertPayloadDetails =
  AddDetailsToAlertPayload
  { addDetailsToAlertPayloadUser = Nothing
  , addDetailsToAlertPayloadNote = Nothing
  , addDetailsToAlertPayloadSource = Nothing
  , addDetailsToAlertPayloadDetails
  }

-- ** AddNoteToAlertPayload
-- | AddNoteToAlertPayload
data AddNoteToAlertPayload = AddNoteToAlertPayload
  { addNoteToAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , addNoteToAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , addNoteToAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddNoteToAlertPayload
instance A.FromJSON AddNoteToAlertPayload where
  parseJSON = A.withObject "AddNoteToAlertPayload" $ \o ->
    AddNoteToAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON AddNoteToAlertPayload
instance A.ToJSON AddNoteToAlertPayload where
  toJSON AddNoteToAlertPayload {..} =
   _omitNulls
      [ "user" .= addNoteToAlertPayloadUser
      , "note" .= addNoteToAlertPayloadNote
      , "source" .= addNoteToAlertPayloadSource
      ]


-- | Construct a value of type 'AddNoteToAlertPayload' (by applying it's required fields, if any)
mkAddNoteToAlertPayload
  :: AddNoteToAlertPayload
mkAddNoteToAlertPayload =
  AddNoteToAlertPayload
  { addNoteToAlertPayloadUser = Nothing
  , addNoteToAlertPayloadNote = Nothing
  , addNoteToAlertPayloadSource = Nothing
  }

-- ** AddResponderToAlertPayload
-- | AddResponderToAlertPayload
data AddResponderToAlertPayload = AddResponderToAlertPayload
  { addResponderToAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , addResponderToAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , addResponderToAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , addResponderToAlertPayloadResponder :: !(Recipient) -- ^ /Required/ "responder"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddResponderToAlertPayload
instance A.FromJSON AddResponderToAlertPayload where
  parseJSON = A.withObject "AddResponderToAlertPayload" $ \o ->
    AddResponderToAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "responder")

-- | ToJSON AddResponderToAlertPayload
instance A.ToJSON AddResponderToAlertPayload where
  toJSON AddResponderToAlertPayload {..} =
   _omitNulls
      [ "user" .= addResponderToAlertPayloadUser
      , "note" .= addResponderToAlertPayloadNote
      , "source" .= addResponderToAlertPayloadSource
      , "responder" .= addResponderToAlertPayloadResponder
      ]


-- | Construct a value of type 'AddResponderToAlertPayload' (by applying it's required fields, if any)
mkAddResponderToAlertPayload
  :: Recipient -- ^ 'addResponderToAlertPayloadResponder' 
  -> AddResponderToAlertPayload
mkAddResponderToAlertPayload addResponderToAlertPayloadResponder =
  AddResponderToAlertPayload
  { addResponderToAlertPayloadUser = Nothing
  , addResponderToAlertPayloadNote = Nothing
  , addResponderToAlertPayloadSource = Nothing
  , addResponderToAlertPayloadResponder
  }

-- ** AddTagsToAlertPayload
-- | AddTagsToAlertPayload
data AddTagsToAlertPayload = AddTagsToAlertPayload
  { addTagsToAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , addTagsToAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , addTagsToAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , addTagsToAlertPayloadTags :: !([Text]) -- ^ /Required/ "tags"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddTagsToAlertPayload
instance A.FromJSON AddTagsToAlertPayload where
  parseJSON = A.withObject "AddTagsToAlertPayload" $ \o ->
    AddTagsToAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "tags")

-- | ToJSON AddTagsToAlertPayload
instance A.ToJSON AddTagsToAlertPayload where
  toJSON AddTagsToAlertPayload {..} =
   _omitNulls
      [ "user" .= addTagsToAlertPayloadUser
      , "note" .= addTagsToAlertPayloadNote
      , "source" .= addTagsToAlertPayloadSource
      , "tags" .= addTagsToAlertPayloadTags
      ]


-- | Construct a value of type 'AddTagsToAlertPayload' (by applying it's required fields, if any)
mkAddTagsToAlertPayload
  :: [Text] -- ^ 'addTagsToAlertPayloadTags' 
  -> AddTagsToAlertPayload
mkAddTagsToAlertPayload addTagsToAlertPayloadTags =
  AddTagsToAlertPayload
  { addTagsToAlertPayloadUser = Nothing
  , addTagsToAlertPayloadNote = Nothing
  , addTagsToAlertPayloadSource = Nothing
  , addTagsToAlertPayloadTags
  }

-- ** AddTeamToAlertPayload
-- | AddTeamToAlertPayload
data AddTeamToAlertPayload = AddTeamToAlertPayload
  { addTeamToAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , addTeamToAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , addTeamToAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , addTeamToAlertPayloadTeam :: !(TeamRecipient) -- ^ /Required/ "team"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddTeamToAlertPayload
instance A.FromJSON AddTeamToAlertPayload where
  parseJSON = A.withObject "AddTeamToAlertPayload" $ \o ->
    AddTeamToAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "team")

-- | ToJSON AddTeamToAlertPayload
instance A.ToJSON AddTeamToAlertPayload where
  toJSON AddTeamToAlertPayload {..} =
   _omitNulls
      [ "user" .= addTeamToAlertPayloadUser
      , "note" .= addTeamToAlertPayloadNote
      , "source" .= addTeamToAlertPayloadSource
      , "team" .= addTeamToAlertPayloadTeam
      ]


-- | Construct a value of type 'AddTeamToAlertPayload' (by applying it's required fields, if any)
mkAddTeamToAlertPayload
  :: TeamRecipient -- ^ 'addTeamToAlertPayloadTeam' 
  -> AddTeamToAlertPayload
mkAddTeamToAlertPayload addTeamToAlertPayloadTeam =
  AddTeamToAlertPayload
  { addTeamToAlertPayloadUser = Nothing
  , addTeamToAlertPayloadNote = Nothing
  , addTeamToAlertPayloadSource = Nothing
  , addTeamToAlertPayloadTeam
  }

-- ** Alert
-- | Alert
data Alert = Alert
  { alertId :: !(Text) -- ^ /Required/ "id"
  , alertTinyId :: !(Maybe Text) -- ^ "tinyId"
  , alertAlias :: !(Maybe Text) -- ^ "alias"
  , alertMessage :: !(Maybe Text) -- ^ "message"
  , alertStatus :: !(Maybe Text) -- ^ "status"
  , alertAcknowledged :: !(Maybe Bool) -- ^ "acknowledged"
  , alertIsSeen :: !(Maybe Bool) -- ^ "isSeen"
  , alertTags :: !(Maybe [Text]) -- ^ "tags"
  , alertSnoozed :: !(Maybe Bool) -- ^ "snoozed"
  , alertSnoozedUntil :: !(Maybe DateTime) -- ^ "snoozedUntil"
  , alertCount :: !(Maybe Int) -- ^ "count"
  , alertLastOccurredAt :: !(Maybe DateTime) -- ^ "lastOccurredAt"
  , alertCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , alertUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt"
  , alertSource :: !(Maybe Text) -- ^ "source"
  , alertOwner :: !(Maybe Text) -- ^ "owner"
  , alertPriority :: !(Maybe Text) -- ^ "priority"
  , alertResponders :: !(Maybe [Responder]) -- ^ "responders"
  , alertIntegration :: !(Maybe AlertIntegration) -- ^ "integration"
  , alertReport :: !(Maybe AlertReport) -- ^ "report"
  , alertActions :: !(Maybe [Text]) -- ^ "actions"
  , alertEntity :: !(Maybe Text) -- ^ "entity"
  , alertDescription :: !(Maybe Text) -- ^ "description"
  , alertDetails :: !(Maybe (Map.Map String Text)) -- ^ "details"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Alert
instance A.FromJSON Alert where
  parseJSON = A.withObject "Alert" $ \o ->
    Alert
      <$> (o .:  "id")
      <*> (o .:? "tinyId")
      <*> (o .:? "alias")
      <*> (o .:? "message")
      <*> (o .:? "status")
      <*> (o .:? "acknowledged")
      <*> (o .:? "isSeen")
      <*> (o .:? "tags")
      <*> (o .:? "snoozed")
      <*> (o .:? "snoozedUntil")
      <*> (o .:? "count")
      <*> (o .:? "lastOccurredAt")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "source")
      <*> (o .:? "owner")
      <*> (o .:? "priority")
      <*> (o .:? "responders")
      <*> (o .:? "integration")
      <*> (o .:? "report")
      <*> (o .:? "actions")
      <*> (o .:? "entity")
      <*> (o .:? "description")
      <*> (o .:? "details")

-- | ToJSON Alert
instance A.ToJSON Alert where
  toJSON Alert {..} =
   _omitNulls
      [ "id" .= alertId
      , "tinyId" .= alertTinyId
      , "alias" .= alertAlias
      , "message" .= alertMessage
      , "status" .= alertStatus
      , "acknowledged" .= alertAcknowledged
      , "isSeen" .= alertIsSeen
      , "tags" .= alertTags
      , "snoozed" .= alertSnoozed
      , "snoozedUntil" .= alertSnoozedUntil
      , "count" .= alertCount
      , "lastOccurredAt" .= alertLastOccurredAt
      , "createdAt" .= alertCreatedAt
      , "updatedAt" .= alertUpdatedAt
      , "source" .= alertSource
      , "owner" .= alertOwner
      , "priority" .= alertPriority
      , "responders" .= alertResponders
      , "integration" .= alertIntegration
      , "report" .= alertReport
      , "actions" .= alertActions
      , "entity" .= alertEntity
      , "description" .= alertDescription
      , "details" .= alertDetails
      ]


-- | Construct a value of type 'Alert' (by applying it's required fields, if any)
mkAlert
  :: Text -- ^ 'alertId' 
  -> Alert
mkAlert alertId =
  Alert
  { alertId
  , alertTinyId = Nothing
  , alertAlias = Nothing
  , alertMessage = Nothing
  , alertStatus = Nothing
  , alertAcknowledged = Nothing
  , alertIsSeen = Nothing
  , alertTags = Nothing
  , alertSnoozed = Nothing
  , alertSnoozedUntil = Nothing
  , alertCount = Nothing
  , alertLastOccurredAt = Nothing
  , alertCreatedAt = Nothing
  , alertUpdatedAt = Nothing
  , alertSource = Nothing
  , alertOwner = Nothing
  , alertPriority = Nothing
  , alertResponders = Nothing
  , alertIntegration = Nothing
  , alertReport = Nothing
  , alertActions = Nothing
  , alertEntity = Nothing
  , alertDescription = Nothing
  , alertDetails = Nothing
  }

-- ** AllRecipient
-- | AllRecipient
-- All recipient
data AllRecipient = AllRecipient
  { allRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , allRecipientId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AllRecipient
instance A.FromJSON AllRecipient where
  parseJSON = A.withObject "AllRecipient" $ \o ->
    AllRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")

-- | ToJSON AllRecipient
instance A.ToJSON AllRecipient where
  toJSON AllRecipient {..} =
   _omitNulls
      [ "type" .= allRecipientType
      , "id" .= allRecipientId
      ]


-- | Construct a value of type 'AllRecipient' (by applying it's required fields, if any)
mkAllRecipient
  :: E'Type -- ^ 'allRecipientType' 
  -> AllRecipient
mkAllRecipient allRecipientType =
  AllRecipient
  { allRecipientType
  , allRecipientId = Nothing
  }

-- ** AssignAlertPayload
-- | AssignAlertPayload
data AssignAlertPayload = AssignAlertPayload
  { assignAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , assignAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , assignAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , assignAlertPayloadOwner :: !(UserRecipient) -- ^ /Required/ "owner"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssignAlertPayload
instance A.FromJSON AssignAlertPayload where
  parseJSON = A.withObject "AssignAlertPayload" $ \o ->
    AssignAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "owner")

-- | ToJSON AssignAlertPayload
instance A.ToJSON AssignAlertPayload where
  toJSON AssignAlertPayload {..} =
   _omitNulls
      [ "user" .= assignAlertPayloadUser
      , "note" .= assignAlertPayloadNote
      , "source" .= assignAlertPayloadSource
      , "owner" .= assignAlertPayloadOwner
      ]


-- | Construct a value of type 'AssignAlertPayload' (by applying it's required fields, if any)
mkAssignAlertPayload
  :: UserRecipient -- ^ 'assignAlertPayloadOwner' 
  -> AssignAlertPayload
mkAssignAlertPayload assignAlertPayloadOwner =
  AssignAlertPayload
  { assignAlertPayloadUser = Nothing
  , assignAlertPayloadNote = Nothing
  , assignAlertPayloadSource = Nothing
  , assignAlertPayloadOwner
  }

-- ** BaseResponseWithExpandable
-- | BaseResponseWithExpandable
data BaseResponseWithExpandable = BaseResponseWithExpandable
  { baseResponseWithExpandableRequestId :: !(Text) -- ^ /Required/ "requestId"
  , baseResponseWithExpandableTook :: !(Float) -- ^ /Required/ "took"
  , baseResponseWithExpandableExpandable :: !(Maybe [Text]) -- ^ "expandable"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseResponseWithExpandable
instance A.FromJSON BaseResponseWithExpandable where
  parseJSON = A.withObject "BaseResponseWithExpandable" $ \o ->
    BaseResponseWithExpandable
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "expandable")

-- | ToJSON BaseResponseWithExpandable
instance A.ToJSON BaseResponseWithExpandable where
  toJSON BaseResponseWithExpandable {..} =
   _omitNulls
      [ "requestId" .= baseResponseWithExpandableRequestId
      , "took" .= baseResponseWithExpandableTook
      , "expandable" .= baseResponseWithExpandableExpandable
      ]


-- | Construct a value of type 'BaseResponseWithExpandable' (by applying it's required fields, if any)
mkBaseResponseWithExpandable
  :: Text -- ^ 'baseResponseWithExpandableRequestId' 
  -> Float -- ^ 'baseResponseWithExpandableTook' 
  -> BaseResponseWithExpandable
mkBaseResponseWithExpandable baseResponseWithExpandableRequestId baseResponseWithExpandableTook =
  BaseResponseWithExpandable
  { baseResponseWithExpandableRequestId
  , baseResponseWithExpandableTook
  , baseResponseWithExpandableExpandable = Nothing
  }

-- ** CloseAlertPayload
-- | CloseAlertPayload
data CloseAlertPayload = CloseAlertPayload
  { closeAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , closeAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , closeAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CloseAlertPayload
instance A.FromJSON CloseAlertPayload where
  parseJSON = A.withObject "CloseAlertPayload" $ \o ->
    CloseAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON CloseAlertPayload
instance A.ToJSON CloseAlertPayload where
  toJSON CloseAlertPayload {..} =
   _omitNulls
      [ "user" .= closeAlertPayloadUser
      , "note" .= closeAlertPayloadNote
      , "source" .= closeAlertPayloadSource
      ]


-- | Construct a value of type 'CloseAlertPayload' (by applying it's required fields, if any)
mkCloseAlertPayload
  :: CloseAlertPayload
mkCloseAlertPayload =
  CloseAlertPayload
  { closeAlertPayloadUser = Nothing
  , closeAlertPayloadNote = Nothing
  , closeAlertPayloadSource = Nothing
  }

-- ** CreateAlertPayload
-- | CreateAlertPayload
data CreateAlertPayload = CreateAlertPayload
  { createAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , createAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , createAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , createAlertPayloadMessage :: !(Text) -- ^ /Required/ "message" - Message of the alert
  , createAlertPayloadAlias :: !(Maybe Text) -- ^ "alias" - Client-defined identifier of the alert, that is also the key element of alert deduplication.
  , createAlertPayloadDescription :: !(Maybe Text) -- ^ "description" - Description field of the alert that is generally used to provide a detailed information about the alert.
  , createAlertPayloadResponders :: !(Maybe [Recipient]) -- ^ "responders" - Responders that the alert will be routed to send notifications
  , createAlertPayloadVisibleTo :: !(Maybe [Recipient]) -- ^ "visibleTo" - Teams and users that the alert will become visible to without sending any notification
  , createAlertPayloadActions :: !(Maybe [Text]) -- ^ "actions" - Custom actions that will be available for the alert
  , createAlertPayloadTags :: !(Maybe [Text]) -- ^ "tags" - Tags of the alert
  , createAlertPayloadDetails :: !(Maybe (Map.Map String Text)) -- ^ "details" - Map of key-value pairs to use as custom properties of the alert
  , createAlertPayloadEntity :: !(Maybe Text) -- ^ "entity" - Entity field of the alert that is generally used to specify which domain alert is related to
  , createAlertPayloadPriority :: !(Maybe E'Priority) -- ^ "priority" - Priority level of the alert
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAlertPayload
instance A.FromJSON CreateAlertPayload where
  parseJSON = A.withObject "CreateAlertPayload" $ \o ->
    CreateAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "message")
      <*> (o .:? "alias")
      <*> (o .:? "description")
      <*> (o .:? "responders")
      <*> (o .:? "visibleTo")
      <*> (o .:? "actions")
      <*> (o .:? "tags")
      <*> (o .:? "details")
      <*> (o .:? "entity")
      <*> (o .:? "priority")

-- | ToJSON CreateAlertPayload
instance A.ToJSON CreateAlertPayload where
  toJSON CreateAlertPayload {..} =
   _omitNulls
      [ "user" .= createAlertPayloadUser
      , "note" .= createAlertPayloadNote
      , "source" .= createAlertPayloadSource
      , "message" .= createAlertPayloadMessage
      , "alias" .= createAlertPayloadAlias
      , "description" .= createAlertPayloadDescription
      , "responders" .= createAlertPayloadResponders
      , "visibleTo" .= createAlertPayloadVisibleTo
      , "actions" .= createAlertPayloadActions
      , "tags" .= createAlertPayloadTags
      , "details" .= createAlertPayloadDetails
      , "entity" .= createAlertPayloadEntity
      , "priority" .= createAlertPayloadPriority
      ]


-- | Construct a value of type 'CreateAlertPayload' (by applying it's required fields, if any)
mkCreateAlertPayload
  :: Text -- ^ 'createAlertPayloadMessage': Message of the alert
  -> CreateAlertPayload
mkCreateAlertPayload createAlertPayloadMessage =
  CreateAlertPayload
  { createAlertPayloadUser = Nothing
  , createAlertPayloadNote = Nothing
  , createAlertPayloadSource = Nothing
  , createAlertPayloadMessage
  , createAlertPayloadAlias = Nothing
  , createAlertPayloadDescription = Nothing
  , createAlertPayloadResponders = Nothing
  , createAlertPayloadVisibleTo = Nothing
  , createAlertPayloadActions = Nothing
  , createAlertPayloadTags = Nothing
  , createAlertPayloadDetails = Nothing
  , createAlertPayloadEntity = Nothing
  , createAlertPayloadPriority = Nothing
  }

-- ** CreateSavedSearchResponse
-- | CreateSavedSearchResponse
data CreateSavedSearchResponse = CreateSavedSearchResponse
  { createSavedSearchResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , createSavedSearchResponseTook :: !(Float) -- ^ /Required/ "took"
  , createSavedSearchResponseData :: !(Maybe SavedSearchMeta) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSavedSearchResponse
instance A.FromJSON CreateSavedSearchResponse where
  parseJSON = A.withObject "CreateSavedSearchResponse" $ \o ->
    CreateSavedSearchResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON CreateSavedSearchResponse
instance A.ToJSON CreateSavedSearchResponse where
  toJSON CreateSavedSearchResponse {..} =
   _omitNulls
      [ "requestId" .= createSavedSearchResponseRequestId
      , "took" .= createSavedSearchResponseTook
      , "data" .= createSavedSearchResponseData
      ]


-- | Construct a value of type 'CreateSavedSearchResponse' (by applying it's required fields, if any)
mkCreateSavedSearchResponse
  :: Text -- ^ 'createSavedSearchResponseRequestId' 
  -> Float -- ^ 'createSavedSearchResponseTook' 
  -> CreateSavedSearchResponse
mkCreateSavedSearchResponse createSavedSearchResponseRequestId createSavedSearchResponseTook =
  CreateSavedSearchResponse
  { createSavedSearchResponseRequestId
  , createSavedSearchResponseTook
  , createSavedSearchResponseData = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , errorResponseTook :: !(Float) -- ^ /Required/ "took"
  , errorResponseMessage :: !(Maybe Text) -- ^ "message"
  , errorResponseCode :: !(Maybe Int) -- ^ "code"
  , errorResponseResponseHeaders :: !(Maybe (Map.Map String [Text])) -- ^ "responseHeaders"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "message")
      <*> (o .:? "code")
      <*> (o .:? "responseHeaders")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "requestId" .= errorResponseRequestId
      , "took" .= errorResponseTook
      , "message" .= errorResponseMessage
      , "code" .= errorResponseCode
      , "responseHeaders" .= errorResponseResponseHeaders
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseRequestId' 
  -> Float -- ^ 'errorResponseTook' 
  -> ErrorResponse
mkErrorResponse errorResponseRequestId errorResponseTook =
  ErrorResponse
  { errorResponseRequestId
  , errorResponseTook
  , errorResponseMessage = Nothing
  , errorResponseCode = Nothing
  , errorResponseResponseHeaders = Nothing
  }

-- ** EscalateAlertToNextPayload
-- | EscalateAlertToNextPayload
data EscalateAlertToNextPayload = EscalateAlertToNextPayload
  { escalateAlertToNextPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , escalateAlertToNextPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , escalateAlertToNextPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , escalateAlertToNextPayloadEscalation :: !(EscalationRecipient) -- ^ /Required/ "escalation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EscalateAlertToNextPayload
instance A.FromJSON EscalateAlertToNextPayload where
  parseJSON = A.withObject "EscalateAlertToNextPayload" $ \o ->
    EscalateAlertToNextPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "escalation")

-- | ToJSON EscalateAlertToNextPayload
instance A.ToJSON EscalateAlertToNextPayload where
  toJSON EscalateAlertToNextPayload {..} =
   _omitNulls
      [ "user" .= escalateAlertToNextPayloadUser
      , "note" .= escalateAlertToNextPayloadNote
      , "source" .= escalateAlertToNextPayloadSource
      , "escalation" .= escalateAlertToNextPayloadEscalation
      ]


-- | Construct a value of type 'EscalateAlertToNextPayload' (by applying it's required fields, if any)
mkEscalateAlertToNextPayload
  :: EscalationRecipient -- ^ 'escalateAlertToNextPayloadEscalation' 
  -> EscalateAlertToNextPayload
mkEscalateAlertToNextPayload escalateAlertToNextPayloadEscalation =
  EscalateAlertToNextPayload
  { escalateAlertToNextPayloadUser = Nothing
  , escalateAlertToNextPayloadNote = Nothing
  , escalateAlertToNextPayloadSource = Nothing
  , escalateAlertToNextPayloadEscalation
  }

-- ** EscalationRecipient
-- | EscalationRecipient
-- Escalation recipient
data EscalationRecipient = EscalationRecipient
  { escalationRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , escalationRecipientId :: !(Maybe Text) -- ^ "id"
  , escalationRecipientName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EscalationRecipient
instance A.FromJSON EscalationRecipient where
  parseJSON = A.withObject "EscalationRecipient" $ \o ->
    EscalationRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON EscalationRecipient
instance A.ToJSON EscalationRecipient where
  toJSON EscalationRecipient {..} =
   _omitNulls
      [ "type" .= escalationRecipientType
      , "id" .= escalationRecipientId
      , "name" .= escalationRecipientName
      ]


-- | Construct a value of type 'EscalationRecipient' (by applying it's required fields, if any)
mkEscalationRecipient
  :: E'Type -- ^ 'escalationRecipientType' 
  -> EscalationRecipient
mkEscalationRecipient escalationRecipientType =
  EscalationRecipient
  { escalationRecipientType
  , escalationRecipientId = Nothing
  , escalationRecipientName = Nothing
  }

-- ** ExecuteCustomAlertActionPayload
-- | ExecuteCustomAlertActionPayload
data ExecuteCustomAlertActionPayload = ExecuteCustomAlertActionPayload
  { executeCustomAlertActionPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , executeCustomAlertActionPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , executeCustomAlertActionPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteCustomAlertActionPayload
instance A.FromJSON ExecuteCustomAlertActionPayload where
  parseJSON = A.withObject "ExecuteCustomAlertActionPayload" $ \o ->
    ExecuteCustomAlertActionPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON ExecuteCustomAlertActionPayload
instance A.ToJSON ExecuteCustomAlertActionPayload where
  toJSON ExecuteCustomAlertActionPayload {..} =
   _omitNulls
      [ "user" .= executeCustomAlertActionPayloadUser
      , "note" .= executeCustomAlertActionPayloadNote
      , "source" .= executeCustomAlertActionPayloadSource
      ]


-- | Construct a value of type 'ExecuteCustomAlertActionPayload' (by applying it's required fields, if any)
mkExecuteCustomAlertActionPayload
  :: ExecuteCustomAlertActionPayload
mkExecuteCustomAlertActionPayload =
  ExecuteCustomAlertActionPayload
  { executeCustomAlertActionPayloadUser = Nothing
  , executeCustomAlertActionPayloadNote = Nothing
  , executeCustomAlertActionPayloadSource = Nothing
  }

-- ** GetAlertAttachmentResponse
-- | GetAlertAttachmentResponse
data GetAlertAttachmentResponse = GetAlertAttachmentResponse
  { getAlertAttachmentResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , getAlertAttachmentResponseTook :: !(Float) -- ^ /Required/ "took"
  , getAlertAttachmentResponseData :: !(Maybe AlertAttachment) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAlertAttachmentResponse
instance A.FromJSON GetAlertAttachmentResponse where
  parseJSON = A.withObject "GetAlertAttachmentResponse" $ \o ->
    GetAlertAttachmentResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON GetAlertAttachmentResponse
instance A.ToJSON GetAlertAttachmentResponse where
  toJSON GetAlertAttachmentResponse {..} =
   _omitNulls
      [ "requestId" .= getAlertAttachmentResponseRequestId
      , "took" .= getAlertAttachmentResponseTook
      , "data" .= getAlertAttachmentResponseData
      ]


-- | Construct a value of type 'GetAlertAttachmentResponse' (by applying it's required fields, if any)
mkGetAlertAttachmentResponse
  :: Text -- ^ 'getAlertAttachmentResponseRequestId' 
  -> Float -- ^ 'getAlertAttachmentResponseTook' 
  -> GetAlertAttachmentResponse
mkGetAlertAttachmentResponse getAlertAttachmentResponseRequestId getAlertAttachmentResponseTook =
  GetAlertAttachmentResponse
  { getAlertAttachmentResponseRequestId
  , getAlertAttachmentResponseTook
  , getAlertAttachmentResponseData = Nothing
  }

-- ** GetAlertResponse
-- | GetAlertResponse
data GetAlertResponse = GetAlertResponse
  { getAlertResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , getAlertResponseTook :: !(Float) -- ^ /Required/ "took"
  , getAlertResponseData :: !(Maybe Alert) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAlertResponse
instance A.FromJSON GetAlertResponse where
  parseJSON = A.withObject "GetAlertResponse" $ \o ->
    GetAlertResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON GetAlertResponse
instance A.ToJSON GetAlertResponse where
  toJSON GetAlertResponse {..} =
   _omitNulls
      [ "requestId" .= getAlertResponseRequestId
      , "took" .= getAlertResponseTook
      , "data" .= getAlertResponseData
      ]


-- | Construct a value of type 'GetAlertResponse' (by applying it's required fields, if any)
mkGetAlertResponse
  :: Text -- ^ 'getAlertResponseRequestId' 
  -> Float -- ^ 'getAlertResponseTook' 
  -> GetAlertResponse
mkGetAlertResponse getAlertResponseRequestId getAlertResponseTook =
  GetAlertResponse
  { getAlertResponseRequestId
  , getAlertResponseTook
  , getAlertResponseData = Nothing
  }

-- ** GetCountAlertsResponse
-- | GetCountAlertsResponse
data GetCountAlertsResponse = GetCountAlertsResponse
  { getCountAlertsResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , getCountAlertsResponseTook :: !(Float) -- ^ /Required/ "took"
  , getCountAlertsResponseData :: !(Maybe GetCountAlertsResponseData) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetCountAlertsResponse
instance A.FromJSON GetCountAlertsResponse where
  parseJSON = A.withObject "GetCountAlertsResponse" $ \o ->
    GetCountAlertsResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON GetCountAlertsResponse
instance A.ToJSON GetCountAlertsResponse where
  toJSON GetCountAlertsResponse {..} =
   _omitNulls
      [ "requestId" .= getCountAlertsResponseRequestId
      , "took" .= getCountAlertsResponseTook
      , "data" .= getCountAlertsResponseData
      ]


-- | Construct a value of type 'GetCountAlertsResponse' (by applying it's required fields, if any)
mkGetCountAlertsResponse
  :: Text -- ^ 'getCountAlertsResponseRequestId' 
  -> Float -- ^ 'getCountAlertsResponseTook' 
  -> GetCountAlertsResponse
mkGetCountAlertsResponse getCountAlertsResponseRequestId getCountAlertsResponseTook =
  GetCountAlertsResponse
  { getCountAlertsResponseRequestId
  , getCountAlertsResponseTook
  , getCountAlertsResponseData = Nothing
  }

-- ** GetRequestStatusResponse
-- | GetRequestStatusResponse
data GetRequestStatusResponse = GetRequestStatusResponse
  { getRequestStatusResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , getRequestStatusResponseTook :: !(Float) -- ^ /Required/ "took"
  , getRequestStatusResponseData :: !(Maybe AlertRequestStatus) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRequestStatusResponse
instance A.FromJSON GetRequestStatusResponse where
  parseJSON = A.withObject "GetRequestStatusResponse" $ \o ->
    GetRequestStatusResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON GetRequestStatusResponse
instance A.ToJSON GetRequestStatusResponse where
  toJSON GetRequestStatusResponse {..} =
   _omitNulls
      [ "requestId" .= getRequestStatusResponseRequestId
      , "took" .= getRequestStatusResponseTook
      , "data" .= getRequestStatusResponseData
      ]


-- | Construct a value of type 'GetRequestStatusResponse' (by applying it's required fields, if any)
mkGetRequestStatusResponse
  :: Text -- ^ 'getRequestStatusResponseRequestId' 
  -> Float -- ^ 'getRequestStatusResponseTook' 
  -> GetRequestStatusResponse
mkGetRequestStatusResponse getRequestStatusResponseRequestId getRequestStatusResponseTook =
  GetRequestStatusResponse
  { getRequestStatusResponseRequestId
  , getRequestStatusResponseTook
  , getRequestStatusResponseData = Nothing
  }

-- ** GetSavedSearchResponse
-- | GetSavedSearchResponse
data GetSavedSearchResponse = GetSavedSearchResponse
  { getSavedSearchResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , getSavedSearchResponseTook :: !(Float) -- ^ /Required/ "took"
  , getSavedSearchResponseData :: !(Maybe SavedSearch) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSavedSearchResponse
instance A.FromJSON GetSavedSearchResponse where
  parseJSON = A.withObject "GetSavedSearchResponse" $ \o ->
    GetSavedSearchResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON GetSavedSearchResponse
instance A.ToJSON GetSavedSearchResponse where
  toJSON GetSavedSearchResponse {..} =
   _omitNulls
      [ "requestId" .= getSavedSearchResponseRequestId
      , "took" .= getSavedSearchResponseTook
      , "data" .= getSavedSearchResponseData
      ]


-- | Construct a value of type 'GetSavedSearchResponse' (by applying it's required fields, if any)
mkGetSavedSearchResponse
  :: Text -- ^ 'getSavedSearchResponseRequestId' 
  -> Float -- ^ 'getSavedSearchResponseTook' 
  -> GetSavedSearchResponse
mkGetSavedSearchResponse getSavedSearchResponseRequestId getSavedSearchResponseTook =
  GetSavedSearchResponse
  { getSavedSearchResponseRequestId
  , getSavedSearchResponseTook
  , getSavedSearchResponseData = Nothing
  }

-- ** GroupRecipient
-- | GroupRecipient
-- Group recipient
data GroupRecipient = GroupRecipient
  { groupRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , groupRecipientId :: !(Maybe Text) -- ^ "id"
  , groupRecipientName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRecipient
instance A.FromJSON GroupRecipient where
  parseJSON = A.withObject "GroupRecipient" $ \o ->
    GroupRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON GroupRecipient
instance A.ToJSON GroupRecipient where
  toJSON GroupRecipient {..} =
   _omitNulls
      [ "type" .= groupRecipientType
      , "id" .= groupRecipientId
      , "name" .= groupRecipientName
      ]


-- | Construct a value of type 'GroupRecipient' (by applying it's required fields, if any)
mkGroupRecipient
  :: E'Type -- ^ 'groupRecipientType' 
  -> GroupRecipient
mkGroupRecipient groupRecipientType =
  GroupRecipient
  { groupRecipientType
  , groupRecipientId = Nothing
  , groupRecipientName = Nothing
  }

-- ** ListAlertAttachmentsResponse
-- | ListAlertAttachmentsResponse
data ListAlertAttachmentsResponse = ListAlertAttachmentsResponse
  { listAlertAttachmentsResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listAlertAttachmentsResponseTook :: !(Float) -- ^ /Required/ "took"
  , listAlertAttachmentsResponseData :: !(Maybe [AlertAttachmentMeta]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAlertAttachmentsResponse
instance A.FromJSON ListAlertAttachmentsResponse where
  parseJSON = A.withObject "ListAlertAttachmentsResponse" $ \o ->
    ListAlertAttachmentsResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON ListAlertAttachmentsResponse
instance A.ToJSON ListAlertAttachmentsResponse where
  toJSON ListAlertAttachmentsResponse {..} =
   _omitNulls
      [ "requestId" .= listAlertAttachmentsResponseRequestId
      , "took" .= listAlertAttachmentsResponseTook
      , "data" .= listAlertAttachmentsResponseData
      ]


-- | Construct a value of type 'ListAlertAttachmentsResponse' (by applying it's required fields, if any)
mkListAlertAttachmentsResponse
  :: Text -- ^ 'listAlertAttachmentsResponseRequestId' 
  -> Float -- ^ 'listAlertAttachmentsResponseTook' 
  -> ListAlertAttachmentsResponse
mkListAlertAttachmentsResponse listAlertAttachmentsResponseRequestId listAlertAttachmentsResponseTook =
  ListAlertAttachmentsResponse
  { listAlertAttachmentsResponseRequestId
  , listAlertAttachmentsResponseTook
  , listAlertAttachmentsResponseData = Nothing
  }

-- ** ListAlertLogsResponse
-- | ListAlertLogsResponse
data ListAlertLogsResponse = ListAlertLogsResponse
  { listAlertLogsResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listAlertLogsResponseTook :: !(Float) -- ^ /Required/ "took"
  , listAlertLogsResponseData :: !(Maybe [AlertLog]) -- ^ "data"
  , listAlertLogsResponsePaging :: !(Maybe AlertPaging) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAlertLogsResponse
instance A.FromJSON ListAlertLogsResponse where
  parseJSON = A.withObject "ListAlertLogsResponse" $ \o ->
    ListAlertLogsResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")
      <*> (o .:? "paging")

-- | ToJSON ListAlertLogsResponse
instance A.ToJSON ListAlertLogsResponse where
  toJSON ListAlertLogsResponse {..} =
   _omitNulls
      [ "requestId" .= listAlertLogsResponseRequestId
      , "took" .= listAlertLogsResponseTook
      , "data" .= listAlertLogsResponseData
      , "paging" .= listAlertLogsResponsePaging
      ]


-- | Construct a value of type 'ListAlertLogsResponse' (by applying it's required fields, if any)
mkListAlertLogsResponse
  :: Text -- ^ 'listAlertLogsResponseRequestId' 
  -> Float -- ^ 'listAlertLogsResponseTook' 
  -> ListAlertLogsResponse
mkListAlertLogsResponse listAlertLogsResponseRequestId listAlertLogsResponseTook =
  ListAlertLogsResponse
  { listAlertLogsResponseRequestId
  , listAlertLogsResponseTook
  , listAlertLogsResponseData = Nothing
  , listAlertLogsResponsePaging = Nothing
  }

-- ** ListAlertNotesResponse
-- | ListAlertNotesResponse
data ListAlertNotesResponse = ListAlertNotesResponse
  { listAlertNotesResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listAlertNotesResponseTook :: !(Float) -- ^ /Required/ "took"
  , listAlertNotesResponseData :: !(Maybe [AlertNote]) -- ^ "data"
  , listAlertNotesResponsePaging :: !(Maybe AlertPaging) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAlertNotesResponse
instance A.FromJSON ListAlertNotesResponse where
  parseJSON = A.withObject "ListAlertNotesResponse" $ \o ->
    ListAlertNotesResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")
      <*> (o .:? "paging")

-- | ToJSON ListAlertNotesResponse
instance A.ToJSON ListAlertNotesResponse where
  toJSON ListAlertNotesResponse {..} =
   _omitNulls
      [ "requestId" .= listAlertNotesResponseRequestId
      , "took" .= listAlertNotesResponseTook
      , "data" .= listAlertNotesResponseData
      , "paging" .= listAlertNotesResponsePaging
      ]


-- | Construct a value of type 'ListAlertNotesResponse' (by applying it's required fields, if any)
mkListAlertNotesResponse
  :: Text -- ^ 'listAlertNotesResponseRequestId' 
  -> Float -- ^ 'listAlertNotesResponseTook' 
  -> ListAlertNotesResponse
mkListAlertNotesResponse listAlertNotesResponseRequestId listAlertNotesResponseTook =
  ListAlertNotesResponse
  { listAlertNotesResponseRequestId
  , listAlertNotesResponseTook
  , listAlertNotesResponseData = Nothing
  , listAlertNotesResponsePaging = Nothing
  }

-- ** ListAlertRecipientsResponse
-- | ListAlertRecipientsResponse
data ListAlertRecipientsResponse = ListAlertRecipientsResponse
  { listAlertRecipientsResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listAlertRecipientsResponseTook :: !(Float) -- ^ /Required/ "took"
  , listAlertRecipientsResponseData :: !(Maybe [AlertRecipient]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAlertRecipientsResponse
instance A.FromJSON ListAlertRecipientsResponse where
  parseJSON = A.withObject "ListAlertRecipientsResponse" $ \o ->
    ListAlertRecipientsResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON ListAlertRecipientsResponse
instance A.ToJSON ListAlertRecipientsResponse where
  toJSON ListAlertRecipientsResponse {..} =
   _omitNulls
      [ "requestId" .= listAlertRecipientsResponseRequestId
      , "took" .= listAlertRecipientsResponseTook
      , "data" .= listAlertRecipientsResponseData
      ]


-- | Construct a value of type 'ListAlertRecipientsResponse' (by applying it's required fields, if any)
mkListAlertRecipientsResponse
  :: Text -- ^ 'listAlertRecipientsResponseRequestId' 
  -> Float -- ^ 'listAlertRecipientsResponseTook' 
  -> ListAlertRecipientsResponse
mkListAlertRecipientsResponse listAlertRecipientsResponseRequestId listAlertRecipientsResponseTook =
  ListAlertRecipientsResponse
  { listAlertRecipientsResponseRequestId
  , listAlertRecipientsResponseTook
  , listAlertRecipientsResponseData = Nothing
  }

-- ** ListAlertsResponse
-- | ListAlertsResponse
data ListAlertsResponse = ListAlertsResponse
  { listAlertsResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listAlertsResponseTook :: !(Float) -- ^ /Required/ "took"
  , listAlertsResponseData :: !(Maybe [BaseAlert]) -- ^ "data"
  , listAlertsResponsePaging :: !(Maybe PageDetails) -- ^ "paging"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAlertsResponse
instance A.FromJSON ListAlertsResponse where
  parseJSON = A.withObject "ListAlertsResponse" $ \o ->
    ListAlertsResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")
      <*> (o .:? "paging")

-- | ToJSON ListAlertsResponse
instance A.ToJSON ListAlertsResponse where
  toJSON ListAlertsResponse {..} =
   _omitNulls
      [ "requestId" .= listAlertsResponseRequestId
      , "took" .= listAlertsResponseTook
      , "data" .= listAlertsResponseData
      , "paging" .= listAlertsResponsePaging
      ]


-- | Construct a value of type 'ListAlertsResponse' (by applying it's required fields, if any)
mkListAlertsResponse
  :: Text -- ^ 'listAlertsResponseRequestId' 
  -> Float -- ^ 'listAlertsResponseTook' 
  -> ListAlertsResponse
mkListAlertsResponse listAlertsResponseRequestId listAlertsResponseTook =
  ListAlertsResponse
  { listAlertsResponseRequestId
  , listAlertsResponseTook
  , listAlertsResponseData = Nothing
  , listAlertsResponsePaging = Nothing
  }

-- ** ListSavedSearchesResponse
-- | ListSavedSearchesResponse
data ListSavedSearchesResponse = ListSavedSearchesResponse
  { listSavedSearchesResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , listSavedSearchesResponseTook :: !(Float) -- ^ /Required/ "took"
  , listSavedSearchesResponseData :: !(Maybe [SavedSearchMeta]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListSavedSearchesResponse
instance A.FromJSON ListSavedSearchesResponse where
  parseJSON = A.withObject "ListSavedSearchesResponse" $ \o ->
    ListSavedSearchesResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "data")

-- | ToJSON ListSavedSearchesResponse
instance A.ToJSON ListSavedSearchesResponse where
  toJSON ListSavedSearchesResponse {..} =
   _omitNulls
      [ "requestId" .= listSavedSearchesResponseRequestId
      , "took" .= listSavedSearchesResponseTook
      , "data" .= listSavedSearchesResponseData
      ]


-- | Construct a value of type 'ListSavedSearchesResponse' (by applying it's required fields, if any)
mkListSavedSearchesResponse
  :: Text -- ^ 'listSavedSearchesResponseRequestId' 
  -> Float -- ^ 'listSavedSearchesResponseTook' 
  -> ListSavedSearchesResponse
mkListSavedSearchesResponse listSavedSearchesResponseRequestId listSavedSearchesResponseTook =
  ListSavedSearchesResponse
  { listSavedSearchesResponseRequestId
  , listSavedSearchesResponseTook
  , listSavedSearchesResponseData = Nothing
  }

-- ** MatchAll
-- | MatchAll
-- Match all filter
data MatchAll = MatchAll
  { matchAllType :: !(E'Type3) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MatchAll
instance A.FromJSON MatchAll where
  parseJSON = A.withObject "MatchAll" $ \o ->
    MatchAll
      <$> (o .:  "type")

-- | ToJSON MatchAll
instance A.ToJSON MatchAll where
  toJSON MatchAll {..} =
   _omitNulls
      [ "type" .= matchAllType
      ]


-- | Construct a value of type 'MatchAll' (by applying it's required fields, if any)
mkMatchAll
  :: E'Type3 -- ^ 'matchAllType' 
  -> MatchAll
mkMatchAll matchAllType =
  MatchAll
  { matchAllType
  }

-- ** MatchAllConditions
-- | MatchAllConditions
-- Match all conditions filter
data MatchAllConditions = MatchAllConditions
  { matchAllConditionsType :: !(E'Type3) -- ^ /Required/ "type"
  , matchAllConditionsConditions :: !(Maybe [Condition]) -- ^ "conditions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MatchAllConditions
instance A.FromJSON MatchAllConditions where
  parseJSON = A.withObject "MatchAllConditions" $ \o ->
    MatchAllConditions
      <$> (o .:  "type")
      <*> (o .:? "conditions")

-- | ToJSON MatchAllConditions
instance A.ToJSON MatchAllConditions where
  toJSON MatchAllConditions {..} =
   _omitNulls
      [ "type" .= matchAllConditionsType
      , "conditions" .= matchAllConditionsConditions
      ]


-- | Construct a value of type 'MatchAllConditions' (by applying it's required fields, if any)
mkMatchAllConditions
  :: E'Type3 -- ^ 'matchAllConditionsType' 
  -> MatchAllConditions
mkMatchAllConditions matchAllConditionsType =
  MatchAllConditions
  { matchAllConditionsType
  , matchAllConditionsConditions = Nothing
  }

-- ** MatchAnyCondition
-- | MatchAnyCondition
-- Match any condition filter
data MatchAnyCondition = MatchAnyCondition
  { matchAnyConditionType :: !(E'Type3) -- ^ /Required/ "type"
  , matchAnyConditionConditions :: !(Maybe [Condition]) -- ^ "conditions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MatchAnyCondition
instance A.FromJSON MatchAnyCondition where
  parseJSON = A.withObject "MatchAnyCondition" $ \o ->
    MatchAnyCondition
      <$> (o .:  "type")
      <*> (o .:? "conditions")

-- | ToJSON MatchAnyCondition
instance A.ToJSON MatchAnyCondition where
  toJSON MatchAnyCondition {..} =
   _omitNulls
      [ "type" .= matchAnyConditionType
      , "conditions" .= matchAnyConditionConditions
      ]


-- | Construct a value of type 'MatchAnyCondition' (by applying it's required fields, if any)
mkMatchAnyCondition
  :: E'Type3 -- ^ 'matchAnyConditionType' 
  -> MatchAnyCondition
mkMatchAnyCondition matchAnyConditionType =
  MatchAnyCondition
  { matchAnyConditionType
  , matchAnyConditionConditions = Nothing
  }

-- ** NoRecipient
-- | NoRecipient
-- No recipient
data NoRecipient = NoRecipient
  { noRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , noRecipientId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NoRecipient
instance A.FromJSON NoRecipient where
  parseJSON = A.withObject "NoRecipient" $ \o ->
    NoRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")

-- | ToJSON NoRecipient
instance A.ToJSON NoRecipient where
  toJSON NoRecipient {..} =
   _omitNulls
      [ "type" .= noRecipientType
      , "id" .= noRecipientId
      ]


-- | Construct a value of type 'NoRecipient' (by applying it's required fields, if any)
mkNoRecipient
  :: E'Type -- ^ 'noRecipientType' 
  -> NoRecipient
mkNoRecipient noRecipientType =
  NoRecipient
  { noRecipientType
  , noRecipientId = Nothing
  }

-- ** ScheduleRecipient
-- | ScheduleRecipient
-- Schedule recipient
data ScheduleRecipient = ScheduleRecipient
  { scheduleRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , scheduleRecipientId :: !(Maybe Text) -- ^ "id"
  , scheduleRecipientName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScheduleRecipient
instance A.FromJSON ScheduleRecipient where
  parseJSON = A.withObject "ScheduleRecipient" $ \o ->
    ScheduleRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON ScheduleRecipient
instance A.ToJSON ScheduleRecipient where
  toJSON ScheduleRecipient {..} =
   _omitNulls
      [ "type" .= scheduleRecipientType
      , "id" .= scheduleRecipientId
      , "name" .= scheduleRecipientName
      ]


-- | Construct a value of type 'ScheduleRecipient' (by applying it's required fields, if any)
mkScheduleRecipient
  :: E'Type -- ^ 'scheduleRecipientType' 
  -> ScheduleRecipient
mkScheduleRecipient scheduleRecipientType =
  ScheduleRecipient
  { scheduleRecipientType
  , scheduleRecipientId = Nothing
  , scheduleRecipientName = Nothing
  }

-- ** SnoozeAlertPayload
-- | SnoozeAlertPayload
data SnoozeAlertPayload = SnoozeAlertPayload
  { snoozeAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , snoozeAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , snoozeAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  , snoozeAlertPayloadEndTime :: !(DateTime) -- ^ /Required/ "endTime" - Date and time that snooze will lose effect
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SnoozeAlertPayload
instance A.FromJSON SnoozeAlertPayload where
  parseJSON = A.withObject "SnoozeAlertPayload" $ \o ->
    SnoozeAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")
      <*> (o .:  "endTime")

-- | ToJSON SnoozeAlertPayload
instance A.ToJSON SnoozeAlertPayload where
  toJSON SnoozeAlertPayload {..} =
   _omitNulls
      [ "user" .= snoozeAlertPayloadUser
      , "note" .= snoozeAlertPayloadNote
      , "source" .= snoozeAlertPayloadSource
      , "endTime" .= snoozeAlertPayloadEndTime
      ]


-- | Construct a value of type 'SnoozeAlertPayload' (by applying it's required fields, if any)
mkSnoozeAlertPayload
  :: DateTime -- ^ 'snoozeAlertPayloadEndTime': Date and time that snooze will lose effect
  -> SnoozeAlertPayload
mkSnoozeAlertPayload snoozeAlertPayloadEndTime =
  SnoozeAlertPayload
  { snoozeAlertPayloadUser = Nothing
  , snoozeAlertPayloadNote = Nothing
  , snoozeAlertPayloadSource = Nothing
  , snoozeAlertPayloadEndTime
  }

-- ** SuccessResponse
-- | SuccessResponse
data SuccessResponse = SuccessResponse
  { successResponseRequestId :: !(Text) -- ^ /Required/ "requestId"
  , successResponseTook :: !(Float) -- ^ /Required/ "took"
  , successResponseResult :: !(Maybe Text) -- ^ "result"
  , successResponseData :: !(Maybe SuccessData) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuccessResponse
instance A.FromJSON SuccessResponse where
  parseJSON = A.withObject "SuccessResponse" $ \o ->
    SuccessResponse
      <$> (o .:  "requestId")
      <*> (o .:  "took")
      <*> (o .:? "result")
      <*> (o .:? "data")

-- | ToJSON SuccessResponse
instance A.ToJSON SuccessResponse where
  toJSON SuccessResponse {..} =
   _omitNulls
      [ "requestId" .= successResponseRequestId
      , "took" .= successResponseTook
      , "result" .= successResponseResult
      , "data" .= successResponseData
      ]


-- | Construct a value of type 'SuccessResponse' (by applying it's required fields, if any)
mkSuccessResponse
  :: Text -- ^ 'successResponseRequestId' 
  -> Float -- ^ 'successResponseTook' 
  -> SuccessResponse
mkSuccessResponse successResponseRequestId successResponseTook =
  SuccessResponse
  { successResponseRequestId
  , successResponseTook
  , successResponseResult = Nothing
  , successResponseData = Nothing
  }

-- ** TeamRecipient
-- | TeamRecipient
-- Team recipient
data TeamRecipient = TeamRecipient
  { teamRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , teamRecipientId :: !(Maybe Text) -- ^ "id"
  , teamRecipientName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamRecipient
instance A.FromJSON TeamRecipient where
  parseJSON = A.withObject "TeamRecipient" $ \o ->
    TeamRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")
      <*> (o .:? "name")

-- | ToJSON TeamRecipient
instance A.ToJSON TeamRecipient where
  toJSON TeamRecipient {..} =
   _omitNulls
      [ "type" .= teamRecipientType
      , "id" .= teamRecipientId
      , "name" .= teamRecipientName
      ]


-- | Construct a value of type 'TeamRecipient' (by applying it's required fields, if any)
mkTeamRecipient
  :: E'Type -- ^ 'teamRecipientType' 
  -> TeamRecipient
mkTeamRecipient teamRecipientType =
  TeamRecipient
  { teamRecipientType
  , teamRecipientId = Nothing
  , teamRecipientName = Nothing
  }

-- ** TeamResponder
-- | TeamResponder
-- Team responder
data TeamResponder = TeamResponder
  { teamResponderType :: !(E'Type4) -- ^ /Required/ "type"
  , teamResponderId :: !(Text) -- ^ /Required/ "id"
  , teamResponderName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamResponder
instance A.FromJSON TeamResponder where
  parseJSON = A.withObject "TeamResponder" $ \o ->
    TeamResponder
      <$> (o .:  "type")
      <*> (o .:  "id")
      <*> (o .:? "name")

-- | ToJSON TeamResponder
instance A.ToJSON TeamResponder where
  toJSON TeamResponder {..} =
   _omitNulls
      [ "type" .= teamResponderType
      , "id" .= teamResponderId
      , "name" .= teamResponderName
      ]


-- | Construct a value of type 'TeamResponder' (by applying it's required fields, if any)
mkTeamResponder
  :: E'Type4 -- ^ 'teamResponderType' 
  -> Text -- ^ 'teamResponderId' 
  -> TeamResponder
mkTeamResponder teamResponderType teamResponderId =
  TeamResponder
  { teamResponderType
  , teamResponderId
  , teamResponderName = Nothing
  }

-- ** TimeOfDayRestrictionInterval
-- | TimeOfDayRestrictionInterval
-- Time of day restriction interval
data TimeOfDayRestrictionInterval = TimeOfDayRestrictionInterval
  { timeOfDayRestrictionIntervalType :: !(E'Type2) -- ^ /Required/ "type"
  , timeOfDayRestrictionIntervalRestriction :: !(Maybe TimeOfDayRestriction) -- ^ "restriction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimeOfDayRestrictionInterval
instance A.FromJSON TimeOfDayRestrictionInterval where
  parseJSON = A.withObject "TimeOfDayRestrictionInterval" $ \o ->
    TimeOfDayRestrictionInterval
      <$> (o .:  "type")
      <*> (o .:? "restriction")

-- | ToJSON TimeOfDayRestrictionInterval
instance A.ToJSON TimeOfDayRestrictionInterval where
  toJSON TimeOfDayRestrictionInterval {..} =
   _omitNulls
      [ "type" .= timeOfDayRestrictionIntervalType
      , "restriction" .= timeOfDayRestrictionIntervalRestriction
      ]


-- | Construct a value of type 'TimeOfDayRestrictionInterval' (by applying it's required fields, if any)
mkTimeOfDayRestrictionInterval
  :: E'Type2 -- ^ 'timeOfDayRestrictionIntervalType' 
  -> TimeOfDayRestrictionInterval
mkTimeOfDayRestrictionInterval timeOfDayRestrictionIntervalType =
  TimeOfDayRestrictionInterval
  { timeOfDayRestrictionIntervalType
  , timeOfDayRestrictionIntervalRestriction = Nothing
  }

-- ** UnAcknowledgeAlertPayload
-- | UnAcknowledgeAlertPayload
data UnAcknowledgeAlertPayload = UnAcknowledgeAlertPayload
  { unAcknowledgeAlertPayloadUser :: !(Maybe Text) -- ^ "user" - Display name of the request owner
  , unAcknowledgeAlertPayloadNote :: !(Maybe Text) -- ^ "note" - Additional note that will be added while creating the alert
  , unAcknowledgeAlertPayloadSource :: !(Maybe Text) -- ^ "source" - Source field of the alert. Default value is IP address of the incoming request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnAcknowledgeAlertPayload
instance A.FromJSON UnAcknowledgeAlertPayload where
  parseJSON = A.withObject "UnAcknowledgeAlertPayload" $ \o ->
    UnAcknowledgeAlertPayload
      <$> (o .:? "user")
      <*> (o .:? "note")
      <*> (o .:? "source")

-- | ToJSON UnAcknowledgeAlertPayload
instance A.ToJSON UnAcknowledgeAlertPayload where
  toJSON UnAcknowledgeAlertPayload {..} =
   _omitNulls
      [ "user" .= unAcknowledgeAlertPayloadUser
      , "note" .= unAcknowledgeAlertPayloadNote
      , "source" .= unAcknowledgeAlertPayloadSource
      ]


-- | Construct a value of type 'UnAcknowledgeAlertPayload' (by applying it's required fields, if any)
mkUnAcknowledgeAlertPayload
  :: UnAcknowledgeAlertPayload
mkUnAcknowledgeAlertPayload =
  UnAcknowledgeAlertPayload
  { unAcknowledgeAlertPayloadUser = Nothing
  , unAcknowledgeAlertPayloadNote = Nothing
  , unAcknowledgeAlertPayloadSource = Nothing
  }

-- ** UserRecipient
-- | UserRecipient
-- User recipient
data UserRecipient = UserRecipient
  { userRecipientType :: !(E'Type) -- ^ /Required/ "type"
  , userRecipientId :: !(Maybe Text) -- ^ "id"
  , userRecipientUsername :: !(Maybe Text) -- ^ "username"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserRecipient
instance A.FromJSON UserRecipient where
  parseJSON = A.withObject "UserRecipient" $ \o ->
    UserRecipient
      <$> (o .:  "type")
      <*> (o .:? "id")
      <*> (o .:? "username")

-- | ToJSON UserRecipient
instance A.ToJSON UserRecipient where
  toJSON UserRecipient {..} =
   _omitNulls
      [ "type" .= userRecipientType
      , "id" .= userRecipientId
      , "username" .= userRecipientUsername
      ]


-- | Construct a value of type 'UserRecipient' (by applying it's required fields, if any)
mkUserRecipient
  :: E'Type -- ^ 'userRecipientType' 
  -> UserRecipient
mkUserRecipient userRecipientType =
  UserRecipient
  { userRecipientType
  , userRecipientId = Nothing
  , userRecipientUsername = Nothing
  }

-- ** UserResponder
-- | UserResponder
-- User responder
data UserResponder = UserResponder
  { userResponderType :: !(E'Type4) -- ^ /Required/ "type"
  , userResponderId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserResponder
instance A.FromJSON UserResponder where
  parseJSON = A.withObject "UserResponder" $ \o ->
    UserResponder
      <$> (o .:  "type")
      <*> (o .:  "id")

-- | ToJSON UserResponder
instance A.ToJSON UserResponder where
  toJSON UserResponder {..} =
   _omitNulls
      [ "type" .= userResponderType
      , "id" .= userResponderId
      ]


-- | Construct a value of type 'UserResponder' (by applying it's required fields, if any)
mkUserResponder
  :: E'Type4 -- ^ 'userResponderType' 
  -> Text -- ^ 'userResponderId' 
  -> UserResponder
mkUserResponder userResponderType userResponderId =
  UserResponder
  { userResponderType
  , userResponderId
  }

-- ** WeekdayTimeRestrictionInterval
-- | WeekdayTimeRestrictionInterval
-- Weekday time restriction interval
data WeekdayTimeRestrictionInterval = WeekdayTimeRestrictionInterval
  { weekdayTimeRestrictionIntervalType :: !(E'Type2) -- ^ /Required/ "type"
  , weekdayTimeRestrictionIntervalRestrictions :: !(Maybe [WeekdayTimeRestriction]) -- ^ "restrictions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WeekdayTimeRestrictionInterval
instance A.FromJSON WeekdayTimeRestrictionInterval where
  parseJSON = A.withObject "WeekdayTimeRestrictionInterval" $ \o ->
    WeekdayTimeRestrictionInterval
      <$> (o .:  "type")
      <*> (o .:? "restrictions")

-- | ToJSON WeekdayTimeRestrictionInterval
instance A.ToJSON WeekdayTimeRestrictionInterval where
  toJSON WeekdayTimeRestrictionInterval {..} =
   _omitNulls
      [ "type" .= weekdayTimeRestrictionIntervalType
      , "restrictions" .= weekdayTimeRestrictionIntervalRestrictions
      ]


-- | Construct a value of type 'WeekdayTimeRestrictionInterval' (by applying it's required fields, if any)
mkWeekdayTimeRestrictionInterval
  :: E'Type2 -- ^ 'weekdayTimeRestrictionIntervalType' 
  -> WeekdayTimeRestrictionInterval
mkWeekdayTimeRestrictionInterval weekdayTimeRestrictionIntervalType =
  WeekdayTimeRestrictionInterval
  { weekdayTimeRestrictionIntervalType
  , weekdayTimeRestrictionIntervalRestrictions = Nothing
  }


-- * Enums


-- ** E'Direction

-- | Enum of 'Text'
data E'Direction
  = E'Direction'Next -- ^ @"next"@
  | E'Direction'Prev -- ^ @"prev"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Direction where toJSON = A.toJSON . fromE'Direction
instance A.FromJSON E'Direction where parseJSON o = P.either P.fail (pure . P.id) . toE'Direction =<< A.parseJSON o
instance WH.ToHttpApiData E'Direction where toQueryParam = WH.toQueryParam . fromE'Direction
instance WH.FromHttpApiData E'Direction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Direction
instance MimeRender MimeMultipartFormData E'Direction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Direction' enum
fromE'Direction :: E'Direction -> Text
fromE'Direction = \case
  E'Direction'Next -> "next"
  E'Direction'Prev -> "prev"

-- | parse 'E'Direction' enum
toE'Direction :: Text -> P.Either String E'Direction
toE'Direction = \case
  "next" -> P.Right E'Direction'Next
  "prev" -> P.Right E'Direction'Prev
  s -> P.Left $ "toE'Direction: enum parse failure: " P.++ P.show s


-- ** E'Field

-- | Enum of 'Text' . 
-- Specifies which alert field will be used in condition. Possible values are message, alias, description, source, entity, tags, actions, extra-properties, recipients or teams
data E'Field
  = E'Field'Message -- ^ @"message"@
  | E'Field'Alias -- ^ @"alias"@
  | E'Field'Description -- ^ @"description"@
  | E'Field'Source -- ^ @"source"@
  | E'Field'Entity -- ^ @"entity"@
  | E'Field'Tags -- ^ @"tags"@
  | E'Field'Actions -- ^ @"actions"@
  | E'Field'Extra_properties -- ^ @"extra-properties"@
  | E'Field'Recipients -- ^ @"recipients"@
  | E'Field'Teams -- ^ @"teams"@
  | E'Field'Priority -- ^ @"priority"@
  | E'Field'Details -- ^ @"details"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Field where toJSON = A.toJSON . fromE'Field
instance A.FromJSON E'Field where parseJSON o = P.either P.fail (pure . P.id) . toE'Field =<< A.parseJSON o
instance WH.ToHttpApiData E'Field where toQueryParam = WH.toQueryParam . fromE'Field
instance WH.FromHttpApiData E'Field where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Field
instance MimeRender MimeMultipartFormData E'Field where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Field' enum
fromE'Field :: E'Field -> Text
fromE'Field = \case
  E'Field'Message -> "message"
  E'Field'Alias -> "alias"
  E'Field'Description -> "description"
  E'Field'Source -> "source"
  E'Field'Entity -> "entity"
  E'Field'Tags -> "tags"
  E'Field'Actions -> "actions"
  E'Field'Extra_properties -> "extra-properties"
  E'Field'Recipients -> "recipients"
  E'Field'Teams -> "teams"
  E'Field'Priority -> "priority"
  E'Field'Details -> "details"

-- | parse 'E'Field' enum
toE'Field :: Text -> P.Either String E'Field
toE'Field = \case
  "message" -> P.Right E'Field'Message
  "alias" -> P.Right E'Field'Alias
  "description" -> P.Right E'Field'Description
  "source" -> P.Right E'Field'Source
  "entity" -> P.Right E'Field'Entity
  "tags" -> P.Right E'Field'Tags
  "actions" -> P.Right E'Field'Actions
  "extra-properties" -> P.Right E'Field'Extra_properties
  "recipients" -> P.Right E'Field'Recipients
  "teams" -> P.Right E'Field'Teams
  "priority" -> P.Right E'Field'Priority
  "details" -> P.Right E'Field'Details
  s -> P.Left $ "toE'Field: enum parse failure: " P.++ P.show s


-- ** E'IdentifierType

-- | Enum of 'Text'
data E'IdentifierType
  = E'IdentifierType'Id -- ^ @"id"@
  | E'IdentifierType'Alias -- ^ @"alias"@
  | E'IdentifierType'Tiny -- ^ @"tiny"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'IdentifierType where toJSON = A.toJSON . fromE'IdentifierType
instance A.FromJSON E'IdentifierType where parseJSON o = P.either P.fail (pure . P.id) . toE'IdentifierType =<< A.parseJSON o
instance WH.ToHttpApiData E'IdentifierType where toQueryParam = WH.toQueryParam . fromE'IdentifierType
instance WH.FromHttpApiData E'IdentifierType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'IdentifierType
instance MimeRender MimeMultipartFormData E'IdentifierType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'IdentifierType' enum
fromE'IdentifierType :: E'IdentifierType -> Text
fromE'IdentifierType = \case
  E'IdentifierType'Id -> "id"
  E'IdentifierType'Alias -> "alias"
  E'IdentifierType'Tiny -> "tiny"

-- | parse 'E'IdentifierType' enum
toE'IdentifierType :: Text -> P.Either String E'IdentifierType
toE'IdentifierType = \case
  "id" -> P.Right E'IdentifierType'Id
  "alias" -> P.Right E'IdentifierType'Alias
  "tiny" -> P.Right E'IdentifierType'Tiny
  s -> P.Left $ "toE'IdentifierType: enum parse failure: " P.++ P.show s


-- ** E'Operation

-- | Enum of 'Text' . 
-- It is the operation that will be executed for the given field and key.
data E'Operation
  = E'Operation'Matches -- ^ @"matches"@
  | E'Operation'Contains -- ^ @"contains"@
  | E'Operation'Starts_with -- ^ @"starts-with"@
  | E'Operation'Ends_with -- ^ @"ends-with"@
  | E'Operation'Equals -- ^ @"equals"@
  | E'Operation'Contains_key -- ^ @"contains-key"@
  | E'Operation'Contains_value -- ^ @"contains-value"@
  | E'Operation'Greater_than -- ^ @"greater-than"@
  | E'Operation'Less_than -- ^ @"less-than"@
  | E'Operation'Is_empty -- ^ @"is-empty"@
  | E'Operation'Equals_ignore_whitespace -- ^ @"equals-ignore-whitespace"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Operation where toJSON = A.toJSON . fromE'Operation
instance A.FromJSON E'Operation where parseJSON o = P.either P.fail (pure . P.id) . toE'Operation =<< A.parseJSON o
instance WH.ToHttpApiData E'Operation where toQueryParam = WH.toQueryParam . fromE'Operation
instance WH.FromHttpApiData E'Operation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Operation
instance MimeRender MimeMultipartFormData E'Operation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Operation' enum
fromE'Operation :: E'Operation -> Text
fromE'Operation = \case
  E'Operation'Matches -> "matches"
  E'Operation'Contains -> "contains"
  E'Operation'Starts_with -> "starts-with"
  E'Operation'Ends_with -> "ends-with"
  E'Operation'Equals -> "equals"
  E'Operation'Contains_key -> "contains-key"
  E'Operation'Contains_value -> "contains-value"
  E'Operation'Greater_than -> "greater-than"
  E'Operation'Less_than -> "less-than"
  E'Operation'Is_empty -> "is-empty"
  E'Operation'Equals_ignore_whitespace -> "equals-ignore-whitespace"

-- | parse 'E'Operation' enum
toE'Operation :: Text -> P.Either String E'Operation
toE'Operation = \case
  "matches" -> P.Right E'Operation'Matches
  "contains" -> P.Right E'Operation'Contains
  "starts-with" -> P.Right E'Operation'Starts_with
  "ends-with" -> P.Right E'Operation'Ends_with
  "equals" -> P.Right E'Operation'Equals
  "contains-key" -> P.Right E'Operation'Contains_key
  "contains-value" -> P.Right E'Operation'Contains_value
  "greater-than" -> P.Right E'Operation'Greater_than
  "less-than" -> P.Right E'Operation'Less_than
  "is-empty" -> P.Right E'Operation'Is_empty
  "equals-ignore-whitespace" -> P.Right E'Operation'Equals_ignore_whitespace
  s -> P.Left $ "toE'Operation: enum parse failure: " P.++ P.show s


-- ** E'Order

-- | Enum of 'Text'
data E'Order
  = E'Order'Asc -- ^ @"asc"@
  | E'Order'Desc -- ^ @"desc"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Order where toJSON = A.toJSON . fromE'Order
instance A.FromJSON E'Order where parseJSON o = P.either P.fail (pure . P.id) . toE'Order =<< A.parseJSON o
instance WH.ToHttpApiData E'Order where toQueryParam = WH.toQueryParam . fromE'Order
instance WH.FromHttpApiData E'Order where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Order
instance MimeRender MimeMultipartFormData E'Order where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Order' enum
fromE'Order :: E'Order -> Text
fromE'Order = \case
  E'Order'Asc -> "asc"
  E'Order'Desc -> "desc"

-- | parse 'E'Order' enum
toE'Order :: Text -> P.Either String E'Order
toE'Order = \case
  "asc" -> P.Right E'Order'Asc
  "desc" -> P.Right E'Order'Desc
  s -> P.Left $ "toE'Order: enum parse failure: " P.++ P.show s


-- ** E'Priority

-- | Enum of 'Text' . 
-- Priority level of the alert
data E'Priority
  = E'Priority'P1 -- ^ @"P1"@
  | E'Priority'P2 -- ^ @"P2"@
  | E'Priority'P3 -- ^ @"P3"@
  | E'Priority'P4 -- ^ @"P4"@
  | E'Priority'P5 -- ^ @"P5"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Priority where toJSON = A.toJSON . fromE'Priority
instance A.FromJSON E'Priority where parseJSON o = P.either P.fail (pure . P.id) . toE'Priority =<< A.parseJSON o
instance WH.ToHttpApiData E'Priority where toQueryParam = WH.toQueryParam . fromE'Priority
instance WH.FromHttpApiData E'Priority where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Priority
instance MimeRender MimeMultipartFormData E'Priority where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Priority' enum
fromE'Priority :: E'Priority -> Text
fromE'Priority = \case
  E'Priority'P1 -> "P1"
  E'Priority'P2 -> "P2"
  E'Priority'P3 -> "P3"
  E'Priority'P4 -> "P4"
  E'Priority'P5 -> "P5"

-- | parse 'E'Priority' enum
toE'Priority :: Text -> P.Either String E'Priority
toE'Priority = \case
  "P1" -> P.Right E'Priority'P1
  "P2" -> P.Right E'Priority'P2
  "P3" -> P.Right E'Priority'P3
  "P4" -> P.Right E'Priority'P4
  "P5" -> P.Right E'Priority'P5
  s -> P.Left $ "toE'Priority: enum parse failure: " P.++ P.show s


-- ** E'SearchIdentifierType

-- | Enum of 'Text'
data E'SearchIdentifierType
  = E'SearchIdentifierType'Id -- ^ @"id"@
  | E'SearchIdentifierType'Name -- ^ @"name"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SearchIdentifierType where toJSON = A.toJSON . fromE'SearchIdentifierType
instance A.FromJSON E'SearchIdentifierType where parseJSON o = P.either P.fail (pure . P.id) . toE'SearchIdentifierType =<< A.parseJSON o
instance WH.ToHttpApiData E'SearchIdentifierType where toQueryParam = WH.toQueryParam . fromE'SearchIdentifierType
instance WH.FromHttpApiData E'SearchIdentifierType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SearchIdentifierType
instance MimeRender MimeMultipartFormData E'SearchIdentifierType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SearchIdentifierType' enum
fromE'SearchIdentifierType :: E'SearchIdentifierType -> Text
fromE'SearchIdentifierType = \case
  E'SearchIdentifierType'Id -> "id"
  E'SearchIdentifierType'Name -> "name"

-- | parse 'E'SearchIdentifierType' enum
toE'SearchIdentifierType :: Text -> P.Either String E'SearchIdentifierType
toE'SearchIdentifierType = \case
  "id" -> P.Right E'SearchIdentifierType'Id
  "name" -> P.Right E'SearchIdentifierType'Name
  s -> P.Left $ "toE'SearchIdentifierType: enum parse failure: " P.++ P.show s


-- ** E'Sort

-- | Enum of 'Text'
data E'Sort
  = E'Sort'CreatedAt -- ^ @"createdAt"@
  | E'Sort'UpdatedAt -- ^ @"updatedAt"@
  | E'Sort'TinyId -- ^ @"tinyId"@
  | E'Sort'Alias -- ^ @"alias"@
  | E'Sort'Message -- ^ @"message"@
  | E'Sort'Status -- ^ @"status"@
  | E'Sort'Acknowledged -- ^ @"acknowledged"@
  | E'Sort'IsSeen -- ^ @"isSeen"@
  | E'Sort'Snoozed -- ^ @"snoozed"@
  | E'Sort'SnoozedUntil -- ^ @"snoozedUntil"@
  | E'Sort'Count -- ^ @"count"@
  | E'Sort'LastOccurredAt -- ^ @"lastOccurredAt"@
  | E'Sort'Source -- ^ @"source"@
  | E'Sort'Owner -- ^ @"owner"@
  | E'Sort'Integration_name -- ^ @"integration.name"@
  | E'Sort'Integration_type -- ^ @"integration.type"@
  | E'Sort'Report_ackTime -- ^ @"report.ackTime"@
  | E'Sort'Report_closeTime -- ^ @"report.closeTime"@
  | E'Sort'Report_acknowledgedBy -- ^ @"report.acknowledgedBy"@
  | E'Sort'Report_closedBy -- ^ @"report.closedBy"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sort where toJSON = A.toJSON . fromE'Sort
instance A.FromJSON E'Sort where parseJSON o = P.either P.fail (pure . P.id) . toE'Sort =<< A.parseJSON o
instance WH.ToHttpApiData E'Sort where toQueryParam = WH.toQueryParam . fromE'Sort
instance WH.FromHttpApiData E'Sort where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sort
instance MimeRender MimeMultipartFormData E'Sort where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sort' enum
fromE'Sort :: E'Sort -> Text
fromE'Sort = \case
  E'Sort'CreatedAt -> "createdAt"
  E'Sort'UpdatedAt -> "updatedAt"
  E'Sort'TinyId -> "tinyId"
  E'Sort'Alias -> "alias"
  E'Sort'Message -> "message"
  E'Sort'Status -> "status"
  E'Sort'Acknowledged -> "acknowledged"
  E'Sort'IsSeen -> "isSeen"
  E'Sort'Snoozed -> "snoozed"
  E'Sort'SnoozedUntil -> "snoozedUntil"
  E'Sort'Count -> "count"
  E'Sort'LastOccurredAt -> "lastOccurredAt"
  E'Sort'Source -> "source"
  E'Sort'Owner -> "owner"
  E'Sort'Integration_name -> "integration.name"
  E'Sort'Integration_type -> "integration.type"
  E'Sort'Report_ackTime -> "report.ackTime"
  E'Sort'Report_closeTime -> "report.closeTime"
  E'Sort'Report_acknowledgedBy -> "report.acknowledgedBy"
  E'Sort'Report_closedBy -> "report.closedBy"

-- | parse 'E'Sort' enum
toE'Sort :: Text -> P.Either String E'Sort
toE'Sort = \case
  "createdAt" -> P.Right E'Sort'CreatedAt
  "updatedAt" -> P.Right E'Sort'UpdatedAt
  "tinyId" -> P.Right E'Sort'TinyId
  "alias" -> P.Right E'Sort'Alias
  "message" -> P.Right E'Sort'Message
  "status" -> P.Right E'Sort'Status
  "acknowledged" -> P.Right E'Sort'Acknowledged
  "isSeen" -> P.Right E'Sort'IsSeen
  "snoozed" -> P.Right E'Sort'Snoozed
  "snoozedUntil" -> P.Right E'Sort'SnoozedUntil
  "count" -> P.Right E'Sort'Count
  "lastOccurredAt" -> P.Right E'Sort'LastOccurredAt
  "source" -> P.Right E'Sort'Source
  "owner" -> P.Right E'Sort'Owner
  "integration.name" -> P.Right E'Sort'Integration_name
  "integration.type" -> P.Right E'Sort'Integration_type
  "report.ackTime" -> P.Right E'Sort'Report_ackTime
  "report.closeTime" -> P.Right E'Sort'Report_closeTime
  "report.acknowledgedBy" -> P.Right E'Sort'Report_acknowledgedBy
  "report.closedBy" -> P.Right E'Sort'Report_closedBy
  s -> P.Left $ "toE'Sort: enum parse failure: " P.++ P.show s


-- ** E'StartDay

-- | Enum of 'Text'
data E'StartDay
  = E'StartDay'Monday -- ^ @"monday"@
  | E'StartDay'Tuesday -- ^ @"tuesday"@
  | E'StartDay'Wednesday -- ^ @"wednesday"@
  | E'StartDay'Thursday -- ^ @"thursday"@
  | E'StartDay'Friday -- ^ @"friday"@
  | E'StartDay'Saturday -- ^ @"saturday"@
  | E'StartDay'Sunday -- ^ @"sunday"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'StartDay where toJSON = A.toJSON . fromE'StartDay
instance A.FromJSON E'StartDay where parseJSON o = P.either P.fail (pure . P.id) . toE'StartDay =<< A.parseJSON o
instance WH.ToHttpApiData E'StartDay where toQueryParam = WH.toQueryParam . fromE'StartDay
instance WH.FromHttpApiData E'StartDay where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'StartDay
instance MimeRender MimeMultipartFormData E'StartDay where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'StartDay' enum
fromE'StartDay :: E'StartDay -> Text
fromE'StartDay = \case
  E'StartDay'Monday -> "monday"
  E'StartDay'Tuesday -> "tuesday"
  E'StartDay'Wednesday -> "wednesday"
  E'StartDay'Thursday -> "thursday"
  E'StartDay'Friday -> "friday"
  E'StartDay'Saturday -> "saturday"
  E'StartDay'Sunday -> "sunday"

-- | parse 'E'StartDay' enum
toE'StartDay :: Text -> P.Either String E'StartDay
toE'StartDay = \case
  "monday" -> P.Right E'StartDay'Monday
  "tuesday" -> P.Right E'StartDay'Tuesday
  "wednesday" -> P.Right E'StartDay'Wednesday
  "thursday" -> P.Right E'StartDay'Thursday
  "friday" -> P.Right E'StartDay'Friday
  "saturday" -> P.Right E'StartDay'Saturday
  "sunday" -> P.Right E'StartDay'Sunday
  s -> P.Left $ "toE'StartDay: enum parse failure: " P.++ P.show s


-- ** E'TimeUnit

-- | Enum of 'Text'
data E'TimeUnit
  = E'TimeUnit'Days -- ^ @"days"@
  | E'TimeUnit'Hours -- ^ @"hours"@
  | E'TimeUnit'Minutes -- ^ @"minutes"@
  | E'TimeUnit'Seconds -- ^ @"seconds"@
  | E'TimeUnit'Miliseconds -- ^ @"miliseconds"@
  | E'TimeUnit'Micros -- ^ @"micros"@
  | E'TimeUnit'Nanos -- ^ @"nanos"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TimeUnit where toJSON = A.toJSON . fromE'TimeUnit
instance A.FromJSON E'TimeUnit where parseJSON o = P.either P.fail (pure . P.id) . toE'TimeUnit =<< A.parseJSON o
instance WH.ToHttpApiData E'TimeUnit where toQueryParam = WH.toQueryParam . fromE'TimeUnit
instance WH.FromHttpApiData E'TimeUnit where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TimeUnit
instance MimeRender MimeMultipartFormData E'TimeUnit where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TimeUnit' enum
fromE'TimeUnit :: E'TimeUnit -> Text
fromE'TimeUnit = \case
  E'TimeUnit'Days -> "days"
  E'TimeUnit'Hours -> "hours"
  E'TimeUnit'Minutes -> "minutes"
  E'TimeUnit'Seconds -> "seconds"
  E'TimeUnit'Miliseconds -> "miliseconds"
  E'TimeUnit'Micros -> "micros"
  E'TimeUnit'Nanos -> "nanos"

-- | parse 'E'TimeUnit' enum
toE'TimeUnit :: Text -> P.Either String E'TimeUnit
toE'TimeUnit = \case
  "days" -> P.Right E'TimeUnit'Days
  "hours" -> P.Right E'TimeUnit'Hours
  "minutes" -> P.Right E'TimeUnit'Minutes
  "seconds" -> P.Right E'TimeUnit'Seconds
  "miliseconds" -> P.Right E'TimeUnit'Miliseconds
  "micros" -> P.Right E'TimeUnit'Micros
  "nanos" -> P.Right E'TimeUnit'Nanos
  s -> P.Left $ "toE'TimeUnit: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'All -- ^ @"all"@
  | E'Type'None -- ^ @"none"@
  | E'Type'User -- ^ @"user"@
  | E'Type'Escalation -- ^ @"escalation"@
  | E'Type'Schedule -- ^ @"schedule"@
  | E'Type'Team -- ^ @"team"@
  | E'Type'Group -- ^ @"group"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'All -> "all"
  E'Type'None -> "none"
  E'Type'User -> "user"
  E'Type'Escalation -> "escalation"
  E'Type'Schedule -> "schedule"
  E'Type'Team -> "team"
  E'Type'Group -> "group"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "all" -> P.Right E'Type'All
  "none" -> P.Right E'Type'None
  "user" -> P.Right E'Type'User
  "escalation" -> P.Right E'Type'Escalation
  "schedule" -> P.Right E'Type'Schedule
  "team" -> P.Right E'Type'Team
  "group" -> P.Right E'Type'Group
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text'
data E'Type2
  = E'Type2'Weekday_and_time_of_day -- ^ @"weekday-and-time-of-day"@
  | E'Type2'Time_of_day -- ^ @"time-of-day"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Weekday_and_time_of_day -> "weekday-and-time-of-day"
  E'Type2'Time_of_day -> "time-of-day"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "weekday-and-time-of-day" -> P.Right E'Type2'Weekday_and_time_of_day
  "time-of-day" -> P.Right E'Type2'Time_of_day
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'All -- ^ @"match-all"@
  | E'Type3'Any_condition -- ^ @"match-any-condition"@
  | E'Type3'All_conditions -- ^ @"match-all-conditions"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'All -> "match-all"
  E'Type3'Any_condition -> "match-any-condition"
  E'Type3'All_conditions -> "match-all-conditions"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "match-all" -> P.Right E'Type3'All
  "match-any-condition" -> P.Right E'Type3'Any_condition
  "match-all-conditions" -> P.Right E'Type3'All_conditions
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text'
data E'Type4
  = E'Type4'User -- ^ @"user"@
  | E'Type4'Team -- ^ @"team"@
  | E'Type4'Escalation -- ^ @"escalation"@
  | E'Type4'Schedule -- ^ @"schedule"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'User -> "user"
  E'Type4'Team -> "team"
  E'Type4'Escalation -> "escalation"
  E'Type4'Schedule -> "schedule"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "user" -> P.Right E'Type4'User
  "team" -> P.Right E'Type4'Team
  "escalation" -> P.Right E'Type4'Escalation
  "schedule" -> P.Right E'Type4'Schedule
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s
